\ Forth kernel for 6502 on C64.
\ These are HOST vocab words that define assembler words on Target - their
\ mirror words are regular.

\ A code definition is the (TCREATE) header, then then code.
: code      ( "name' -- ) (TCREATE) ;
: end-code  ( -- )        next, ;
\ End marker, but no NEXT.
: end-code-bare ( -- ) ;


\ Arithmetic =================================================================
: binary, ( pre-xt op-xt )
    >R
    ( pre-xt ) execute
    0 zp,x lda,
    2 zp,x R@ execute
    2 zp,x sta,
    1 zp,x lda,
    3 zp,x R> execute
    3 zp,x sta,
    inx, inx, ;

: noop ( -- ) ;

code +    ' clc, ' adc, binary, end-code
code -    ' sec, ' sbc, binary, end-code
code AND  ' noop ' and, binary, end-code
code OR   ' noop ' ora, binary, end-code
code XOR  ' noop ' eor, binary, end-code

\ TODO: LSHIFT RSHIFT ARSHIFT as Forth loops.

code 2* label 2*-inner  0 zp,x asl,   1 zp,x rol,   end-code
code 2/                 1 zp,x lsr,   0 zp,x ror,   end-code

code INVERT
    $ff # lda,   0 zp,x eor,   0 zp,x sta,
    $ff # lda,   1 zp,x eor,   1 zp,x sta,
end-code


\ Multiplication =============================================================
\ Taken from _Assembly in One Step_'s example 5-6 - 16x16 -> 32-bit multiply.
\ The operands are taken from the stack, and the product in W_lo .. W2_hi.
\ Call the 4 product bytes, low to high, p0 to p3.
code UM* ( u u -- ud )
  0   #  lda,        \ Clear the upper two bytes of the result.
  w2l zp sta,
  w2h zp sta,
  16  #  ldy,        \ Multiplier bit count of 16.

  label UM*-next-bit
    1 zp,x lsr,      \ Shift two-byte multiplier (TOS) right
    0 zp,x ror,
    cs? if,          \ If we just shifted out a 1, add to the result.
      w2l zp lda,    \ Fetch p2
      clc,
      2   zp,x adc,  \ Add NOS_lo to it
      w2l zp   sta,  \ And store it back
      w2h zp   lda,
      3   zp,x adc,  \ Then NOS_hi + p3, but DON'T write it back.
    then,
    acc ror,         \ Rotate the four-byte product right.
    w2h zp   sta,    \ Write p3
    w2l zp   ror,
    wh  zp   ror,
    wl  zp   ror,
    dey,             \ Decrement the bit count.
    UM*-next-bit bne,

  \ End of loop - product is in W (low) and W2 (high).
  \ Double-cell values are stored ( lo hi ), so overwrite NOS and TOS.
  w2h zp   lda,   3   zp,x sta,
  w2l zp   lda,   2   zp,x sta,
  wh  zp   lda,   1   zp,x sta,
  wl  zp   lda,   0   zp,x sta,
end-code


\ Comparisons ================================================================
code =
    1 zp,x lda,
    3 zp,x cmp,
    0 # ldy,
    eq? if,
        0 zp,x lda,
        2 zp,x cmp,
        eq? if,
            $ff # ldy,
        then,
    then,
    2 zp,x sty,
    3 zp,x sty,
    inx, inx,
end-code

\ Signed inequalities are hard, since they depend on the sign bits.
\ Unsigned ones first.
code U<
    0 #    ldy,   \ Assume failure.
    1 zp,x lda,   \ TOS_hi -> A
    3 zp,x cmp,   \ TOS_hi - NOS_hi
    \ If N is set, NOS_hi is unsigned-larger than TOS_hi - so NOS > TOS.
    pl? if,     \ N not set, so check Z.
        eq? if, \ Z is set, so we need to check the lo bytes.
            0 zp,x lda, \ TOS_lo -> A
            2 zp,x cmp, \ TOS_lo - NOS_lo
            \ If N is clear, NOS_lo is unsigned-smaller than TOS_lo, return true.
            pl? if,
                $ff # ldy,
            then,
            \ Here: equal hi bytes, flag set per lo bytes.
        then,
    then,
    \ Flag should be set appropriately.
    inx, inx,
    0 zp,x sty,
    1 zp,x sty, \ Write the flag onto TOS.
end-code

\ TODO: Some kind of conditional compilation of target words - these are
\ overwritten in shared/basics.ft currently.
code 0= ( x -- ? )
  $ff #    ldy,
  1   zp,x lda,
  0   zp,x ora,
  ne? if,
    0 # ldy,
  then,
  0   zp,x sty,
  1   zp,x sty,
end-code

code 0< ( x -- ? )
  $ff #    lda,
  1   zp,x ldy,
  pl? if,
    0 # lda,
  then,
  0   zp,x sta,
  1   zp,x sta,
end-code

code <  ( lhs rhs -- ? ) \ Subtracting TOS from NOS.
  0 zp,x lda,
  2 zp,x cmp,
  1 zp,x lda,
  3 zp,x sbc,
  vc? if,
    $80 # eor,
  then,
  \ Top bit of A is now 1 if <, 0 if >=. Convert that to a Forth flag.
  $80 # and,   \ Check that top bit - if it's 0 A is now 0.
  ne? if,
    $ff # lda, \ And if it wasn't 0, A is now $ff
  then,
  2 zp,x sta,
  3 zp,x sta,  \ Store A to both parts of NOS.
  inx, inx,    \ Pop one stack cell.
end-code


\ Stack operations ===========================================================
code DUP
label DUP-code
    dex, dex,
    2 0 stack-cp,
end-code

code DROP inx, inx, end-code

code OVER
    dex, dex,
    4 0 stack-cp,
end-code

code SWAP
    2 0 w-swap,
end-code

code ROT ( 45 23 01 -- 23 01 45 )
    4 zp,x ldy,
    2 zp,x lda,
    4 zp,x sta,
    0 zp,x lda,
    2 zp,x sta,
    0 zp,x sty,

    5 zp,x ldy,
    3 zp,x lda,
    5 zp,x sta,
    1 zp,x lda,
    3 zp,x sta,
    1 zp,x sty,
end-code

code -ROT ( 45 23 01 -- 01 45 23 )
    0 zp,x ldy,
    2 zp,x lda,
    0 zp,x sta,
    4 zp,x lda,
    2 zp,x sta,
    4 zp,x sty,

    1 zp,x ldy,
    3 zp,x lda,
    1 zp,x sta,
    5 zp,x lda,
    3 zp,x sta,
    5 zp,x sty,
end-code

code ?DUP
    0 zp,x lda,
    1 zp,x ora,
    ne? if, \ If the combo is not 0, jump to DUP
        DUP-code $ jmp,
    then,
end-code

code NIP ( y x -- x ) 0 2 stack-cp, inx, inx, end-code

code TUCK ( y x -- x y x )
    dex, dex,
    2 0 stack-cp,
    4 2 stack-cp,
    0 4 stack-cp,
end-code

code 2DUP ( y x -- y x y x )
    dex, dex, dex, dex,
    4 0 stack-cp,
    6 2 stack-cp,
end-code

code 2DROP ( z y x w -- )
  inx, inx, inx, inx,
end-code

code 2SWAP ( z y x w -- x w z y )
    0 4 w-swap,
    2 6 w-swap,
end-code

code 2OVER ( z y x w -- z y x w z y )
    dex, dex, dex, dex,
    10 2 stack-cp,
     8 0 stack-cp,
end-code

code SP@ ( -- psp )
    txa,       \ Get the X before we move the stack pointer.
    dex, dex,
    0 zp,x sta,
    \ High byte is always 0
    0 #    lda,
    1 zp,x sta,
end-code

code SP! ( psp -- )
    0 zp,x lda,
    tax,
end-code

\ The return stack will have the address after the RP@ call on it.
\ RP! will want to return from RP! to the caller of RP@ - so that works.
code RP@
    wl zp stx,  \ Preserve PSP
    tsx,        \ Get the hardware stack pointer.
    txa, tay,   \ And put it in Y.
    wl zp ldx,  \ Put PSP back
    dex, dex,   \ Make space
    0 zp,x sty, \ Low byte is S (from Y)
    1 #    lda, \ High byte is always 1.
    1 zp,x sta,
end-code

code RP!
    0 zp,x lda, \ Low byte - the new S.
    inx, inx,   \ Drop the value off the stack.
    wl zp stx,  \ Set PSP aside.
    tax,        \ Put the new S in X.
    txs,        \ Then S
    wl zp ldx,  \ And put PSP back.
end-code


code >R >R, end-code
code R> R>, end-code
code R@
    R>W, W>R, \ W now holds the value.
    dex, dex,
    wl zp>tos,
end-code

\ Depth is $80 - X, shifted right by 1.
code DEPTH
    wl zp stx,  \ Put the current X into memory.
    $80 # lda,  \ $80 in A
    sec,
    wl zp sbc,  \ $80-X in A now.
    dex, dex,
    acc lsr,        \ ($80-X)/2 in A
    0 zp,x sta, \ That's the low byte.
    0 #    lda,
    1 zp,x sta, \ High byte is always 0.
end-code


\ Memory =====================================================================
code @
    wl tos>ZP,     \ Set aside the address.
    0 # ldy,       \ Offset of 0 in Y
    wl (zp),y lda, \ Lo byte -> A
    0  zp,x   sta, \ Into TOS
    iny,
    wl (zp),y lda, \ Hi byte -> A
    1  zp,x   sta, \ Into TOS
end-code

code ! ( value addr -- )
    wl tos>ZP,     \ Set aside the address.
    0 # ldy,       \ 0 -> Y
    2  zp,x   lda, \ NOS_lo -> A
    wl (zp),y sta, \ Lo byte -> mem
    iny,           \ 1 -> Y
    3  zp,x   lda, \ NOS_hi -> A
    wl (zp),y sta, \ Hi byte -> mem
    inx, inx, inx, inx,
end-code

code C@ ( c-addr -- b )
    0 (zp,x) lda,
    0 zp,x   sta,
    0 #      lda,
    1 zp,x   sta, \ High byte is always 0
end-code

code C! ( b c-addr -- )
    2 zp,x   lda,
    0 (zp,x) sta,
    inx, inx, inx, inx,
end-code

\ code 2@ ( a-addr -- [a-addr+2] [a-addr] )
\   wl TOS>ZP,
\   dex, dex,
\   wl (zp)>tos,   \ [a-addr] -> TOS
\   2  #      ldy, \ TODO: Maybe bad (zp),y
\   wl (zp),y lda,
\   2  zp,x   sta,
\   iny,
\   wl (zp),y lda,
\   3  zp,x   sta,
\ end-code
\ 
\ code 2! ( [addr+2] [addr] addr -- )
\   wl tos>zp,
\   inx, inx,
\   wl tos>(zp),
\   inx, inx,
\   wl tos>(zp),
\ end-code

code +! ( delta addr -- )
    wl tos>ZP,
    0  #      ldy, \ 0 -> Y
    clc,
    2  zp,x   lda, \ delta_lo -> A
    wl (zp),y adc, \ mem_lo + delta_lo -> A
    wl (zp),y sta, \ result_lo -> mem_lo
    iny,
    3  zp,x   lda, \ delta_hi -> A
    wl (zp),y adc, \ mem_hi + delta_hi -> A
    wl (zp),y sta, \ result_hi -> mem_hi
    inx, inx, inx, inx,
end-code

code EXECUTE ( xt -- )
    \ Pop the xt into W, then JMP-indirect through it.
    wl tos>ZP,
    inx, inx,
    wl $ (jmp), \ That will return to the caller of EXECUTE, as intended.
end-code-bare

\ TODO: BREAK? Is there any way to trigger a breakpoint on C64?


\ Variables and core states ==================================================
label var_latest      0 asm,16
label var_base        0 asm,16
label var_state       0 asm,16
label var_handler     0 asm,16

label var_last_parse  0 asm,16 0 asm,16
label var_source      0 asm,16 0 asm,16
label var_in_ptr      0 asm,16
label var_source_id   0 asm,16
label input-buf       128 there +!

\ The dictionary pointer is in the zero page for speed.
code DP herel lit, end-code

label var_dp_ptr 0 asm,16

code , ( x -- )
    0     zp,x   lda,
    0     #      ldy,
    herel (zp),y sta,
    1     zp,x   lda,
    iny,
    herel (zp),y sta,

    2 herel ZP+,
    inx, inx,
end-code

code C, ( b -- )
    0     zp,x   lda,
    0     #      ldy,
    herel (zp),y sta,
    1 herel ZP+,
    inx, inx,
end-code

\ Compilation means compiling a JSR byte first, then jumping into , above.
\ OPT: This could probably be optimized for space at the cost of speed.
code COMPILE, ( xt -- )
    \ Write the opcode for JSR $1234: $20.
    0     #      ldy,
    $20   #      lda,
    herel (zp),y sta, \ $20 -> (dp)
    iny,
    0     zp,x   lda,
    herel (zp),y sta, \ xt_lo -> (dp+1)
    iny,
    1     zp,x   lda,
    herel (zp),y sta, \ xt_hi -> (dp+2)

    3 herel ZP+,
    inx, inx,
end-code


code HANDLER      var_handler    lit, end-code
code 'LATEST      var_latest     lit, end-code
code STATE        var_state      lit, end-code
code BASE         var_base       lit, end-code
code 'SOURCE      var_source     lit, end-code
code 'SOURCE-ID   var_source_id  lit, end-code
code >IN          var_in_ptr     lit, end-code
code TIB          input-buf      lit, end-code
code LAST-PARSE   var_last_parse lit, end-code
code F_IMMED      f_immed        lit, end-code


\ More arithmetic ============================================================
code 1+
  0 zp,x inc,
  eq? if,
    1 zp,x inc,
  then,
end-code

code 1-
  0 zp,x dec,
  eq? if,
    1 zp,x dec,
  then,
end-code

code CELL   2 lit,                    end-code
code CELLS  2*-inner $ jmp,           end-code-bare
code CHARS                            end-code
code CELL+  2 TOS+lit,                end-code
code CHAR+  1 TOS+lit,                end-code

code BYTES  ( x -- x_lo x_hi )
  dex, dex,
  3 zp,x lda,   0 zp,x sta,   \ Put x_hi into the new bottom slot.
  0 #    lda,
  3 zp,x sta,   1 zp,x sta,   \ And 0 into the two high bytes.
end-code

\ Double-cell arithmetic =====================================================
\ Minimal set - the words used in shared/: S>D D+ UDM*
\ Note that we already have UM* ( u u -- ud )
\ TODO: Implement the rest.

code S>D
  dex, dex,
  0 #    lda,
  0 zp,x sta,
  1 zp,x sta,
end-code

: ripple-add, ( zpA zpB -- )
  ( zpB) zp,x lda,
  dup    zp,x adc,
  ( zpA) zp,x sta, ;

code D+ ( l1 h1 l2 h2 -- l3 h3 )
  \ Two 4-byte values to be added all together. Results written over NOS.
  clc,
  4 0 ripple-add,
  5 1 ripple-add,
  6 2 ripple-add,
  7 3 ripple-add,
  inx, inx, inx, inx,
end-code


code UM/MOD ( ulo uhi udiv -- ur uq )
  \ Dividing a 32-bit unsigned dividend by an unsigned 16-bit divisor to get
  \ an unsigned 16-bit quotient and unsigned 16-bit remainder.
  \ This works by successive bit-shifting until we run out of divisor bits.
  \ The dividend goes in W (lo) and W2 (hi); then W2 holds the remainder and
  \ W the quotient.
  \ Each steps shifts this pair left, moving the top bit of the low/quotient
  \ into the high/remainder.
  \ We shift in a 0 there, but if the remainder is >= the divisor, we subtract
  \ the divisor from the remainder and make bit 0 of the quotient 1.
  \ After cycling for as many bits as the divisor is wide (16), all the dividend
  \ bits have been shifted out of the quotient, and the remainder holds exactly
  \ the remainder we want!
  \ W2 = high dividend/remainder; W = low dividend/quotient   (r0 and r1)
  4 zp,x lda,   wl  zp,x sta,
  5 zp,x lda,   wh  zp,x sta,  \ ulo -> W
  2 zp,x lda,   w2l zp,x sta,
  3 zp,x lda,   w2h zp,x sta,  \ uhi -> W2
  16 # ldy,                    \ bit count -> Y

  label UM/MOD-loop
    \ Shift W2:W left as a 32-bit value.
    wl  zp asl,
    wh  zp rol,
    w2l zp rol,
    w2h zp rol,

    \ If the divisor is U<= the remainder, drain the remainder and put a 1 into
    \ the quotient. That's TOS U<= W2, or W2 U> TOS. If we subtract TOS-W2, then
    \ a borrow will be needed iff W2 U> TOS. So we check C clear = borrowed.
    0   zp,x lda,
    w2l zp   cmp, \ CMP first, then SBC for subsequent ones. Avoids SEC.
    1   zp,x lda,
    w2h zp   sbc,
    cc? if,
      \ divisor U<= remainder, so it's too big.
      \ Subtract divisor (TOS) from remainder (W2),
      \ and make the low bit of the quotient (W) a 1.
      sec,
      w2l zp   lda,
      0   zp,x sbc,
      w2l zp   sta,
      w2h zp   lda,
      1   zp,x sbc,
      w2h zp   sta,
      wl  zp   inc, \ It was just shifted left, so the low bit is always 0.
    then,

    dey,
  UM/MOD-loop bne, \ Keep looping if it's not 0 yet.

  \ Now W2 is the remainder, W the quotient.
  inx, inx,       \ Pop the divisor; there's too many values on the stack.
  wl  zp   lda,   0 zp,x sta,
  wh  zp   lda,   1 zp,x sta,
  w2l zp   lda,   2 zp,x sta,
  w2h zp   lda,   3 zp,x sta,
end-code


\ MOVEs ======================================================================
code MOVE< ( src dst u -- ) \ Copies from low addresses to high.
  \ This uses (zp),Y addressing to copy bytes relatively painlessly.
  \ It can use 8-bit INYs most of the time, and use the Z flag to determine
  \ if carrying if necessary.
  \ First check if the length is all 0.
  0 zp,x lda,   1 zp,x ora,
  eq? if, txa, clc, 6 # adc, tax, rts, then, \ Pop all 3 and return if so.

  wl  tos>ZP,   \ len -> W
  inx, inx,
  w3l tos>ZP,   \ dst -> W3
  inx, inx,
  w2l tos>ZP,   \ src -> W2

  txa, pha,     \ Push PSP (X).

  \ Len in X counting down; memory offset in Y
  0  #  ldy,
  wl zp ldx,

  label MOVE<-loop
    w2l (zp),Y  lda,    \ 5c
    w3l (zp),Y  sta,    \ 6c
    iny,                \ 2c
    eq? if, \ If that just rolled over to 0, increment the pointers.  (BNE: 3c x255 + 2c x1)
      w2h zp    inc,    \ 5c \
      w3h zp    inc,    \ 5c /\ these only run every 256 cycles.
    then,

    dex,    \ Then decrement the length to go.    2c

    \ Fast case: if that DEX left it nonzero, continue.
    MOVE<-loop bne,                             \ 3c x 255 + 2c x 1

    \ Slow case: decrement the high byte of the length.
    \ Note that X is already 0 in this case, ready to continue.
    wh  zp      dec, \ If that left a 0, we're done with the loop.    \ 5c   every 256 only
    MOVE<-loop  bne, \ So continue if nonzero,                        \ 3c   same
    pla, tax, rts,   \ or pull the old X and return if zero.

\ Total to move X bytes:
\ 5 + 6 + 2 + 3 + 2 + 3 per byte copied = 21 cycles per byte
\ Every page = 256B, an extra 5 + 5 + -1 + -1 + 5 + 3 = 16c


code MOVE> ( src dst u -- ) \ Copies from high addresses to low.
  \ This uses (zp),Y addressing to copy bytes relatively painlessly.
  \ It can use 8-bit INYs most of the time, and use the Z flag to determine
  \ if carrying is necessary.
  \ Note that due to the nature of the arithmetic that MOVE< is faster and
  \ should be preferred if memory regions don't overlap.

  \ First check if the length is all 0.
  0 zp,x lda,   1 zp,x ora,
  eq? if, txa, clc, 6 # adc, tax, rts, then, \ Pop all 3 and return if so.

  wl  tos>ZP,   \ len -> W
  inx, inx,
  w3l tos>ZP,   \ dst -> W3
  inx, inx,
  w2l tos>ZP,   \ src -> W2

  txa, pha,     \ Push PSP (X).

  \ Len in X counting down; memory offset in Y
  \ Offset starts at 0; when it is 0 and gets decremented to $ff, we decrement
  \ the pointers as well.
  0  #  ldy,
  wl zp ldx,

  label MOVE>-loop
    w2l (zp),Y  lda,
    w3l (zp),Y  sta,
    tya,
    eq? if, \ If Y is 0 and about to go to $FF, decrement the pointers.
      w2h zp dec,
      w3h zp dec,
    then,
    dey,    \ Then actually decrement the offset
    dex,    \ and the length.

    \ Fast case: if that DEX left it nonzero, continue.
    MOVE>-loop bne,

    \ Slow case: decrement the high byte o the length.
    \ Note that X is already 0 in this case, ready to continue.
    wh  zp     dec,  \ If that left a 0, we're done with the loop.
    MOVE>-loop bne,  \ So continue if nonzero,
    pla, tax, rts,   \ or pull the old X and return if zero.


code FILL ( c-addr u char -- )
  wl  tos>zp,   \ char -> W
  inx, inx,
  w2l  tos>zp,  \ len  -> W2
  inx, inx,
  w3l  tos>zp,  \ addr -> W3
  inx, inx,

  \ Put the low byte of the length into Y.
  w2l zp ldy,
  label FILL-loop
    eq? if, \ Low byte of length in Y is 0.
      w2h zp lda, \ len_hi -> A
      eq? if,     \ If *that* is 0, we're done.
        rts,
      then,
      \ If we're still here, decrement the high byte and continue.
      \ Y is still 0, which is fine.
      w2h zp dec,
    then,

    wl  zp lda, \ ch -> A
    w3l $  sta, \ A  -> mem
    w3l zp inc, \ Bump addr_lo
    eq? if,     \ If it just rolled over to 0, bump hi as well.
      w3h zp inc,
    then,
    dey,
  FILL-loop $ jmp,
end-code-bare   \ It jumps out of the middle when done.


\ DO LOOP machinery ==========================================================
\ DO LOOPs can be built right in as loops inside the containing word, using
\ the (return) stack for nesting and a ZP cell for the current index.
\ The setup and tear-down machinery (DO) and (LOOP-END) are too lengthy to
\ inline, however.
code (DO) \ ( limit index --     R: ret -- old_index limit ret )
  R>W,                       \ Get return address out of the way.
  indexh zp   lda,   pha,    \ Push old index_hi
  indexl zp   lda,   pha,    \ Push old index_lo
  3      zp,x lda,   pha,    \ Push limit_hi
  2      zp,x lda,   pha,    \ Push limit_lo
  indexl tos>zp,             \ New limit in index register.
  inx, inx, inx, inx,        \ Drain stack
  wl $ (jmp),                \ Jump-indirect to W, the return address.
end-code-bare \ No need to return.

code (LOOP-END) ( delta -- done?     R: old-index limit ret -- ditto )
  rsp>Y,            \ Juggle the RSP into Y
  \ Put 0 into W3_lo and _hi for later use.
  0   #  lda,
  w3l zp sta,
  w3h zp sta,

  \ We need index - limit first, in W.
  sec,
  indexl zp  lda,
  $0102  $,y sbc,
  wl     zp  sta,   \ index - limit LO -> W_lo
  indexh zp  lda,
  $0103  $,y sbc,
  wh     zp  sta,   \ index - limit HI -> W_hi

  \ Add it to the delta from TOS into W2 (we still need the delta).
  clc,
  0   zp,x lda,
  wl  zp   adc,
  w2l zp   sta,
  1   zp,x lda,
  wh  zp   adc,
  w2h zp   sta,     \ delta + index - limit -> W2

  \ XOR the high bytes of d+i-l and i-l
  \ d+i-l_hi is still in A.
  wl zp eor,
  pl? if, \ If N is clear, ie. same flag, set -1 into W3_lo, the first flag.
    $ff #  lda,
    w3l zp sta,
  then,

  \ Then calculate delta_hi XOR i-l_hi
  \ i-l is in W; delta in TOS.
  wh zp   lda,
  0  zp,x eor,
  pl? if,      \ N clear = same sign, store $ff into W3_hi, second flag.
    $ff #  lda,
    w3h zp sta,
  then,

  w3h zp lda,  \ Second flag   -> A
  w3l zp ora,  \ OR first flag -> A
  $ff #  eor,  \ Negate it - this is the done flag.
  w3l zp sta,  \ Done flag -> W3_lo for a sec

  clc,
  indexl zp   lda,
  0      zp,x adc,
  indexl zp   sta,
  indexh zp   lda,
  1      zp,x adc,
  indexh zp   sta,   \ index + delta -> index

  \ Get the done flag from W3_lo to both bytes of TOS.
  w3l zp   lda,
  0   zp,x sta,
  1   zp,x sta,
end-code


code UNLOOP ( -- R: old-index limit ret -- ret )
  R>W,
  pla, pla,
  pla,   indexl zp sta,
  pla,   indexh zp sta,
  wl $ (jmp),
end-code-bare

code I ( -- index1 )
  dex, dex,
  indexl zp   lda,
  0      zp,x sta,
  indexh zp   lda,
  1      zp,x sta,
end-code

code J ( -- old-index   R: old-index limit ret -- old-index limit ret )
  dex, dex,
  rsp>Y,              \ Juggle the RSP into Y
  $104 $,y  lda,      \ old-index_lo -> A
  0    zp,x sta,      \ -> TOS_lo
  $105 $,y  lda,      \ old-index_hi -> A
  1    zp,x sta,      \ -> TOS_hi
end-code

\ Cursor and screen handling =================================================
code CURSOR ( -- a-addr ) \ The address of the cursor field itself.
  dex, dex,
  cursorl #    lda,
  0       zp,x sta,
  cursorh #    lda,
  1       zp,x sta,
end-code

code CLEAR-SCREEN
label CLEAR-SCREEN-top
  0 # ldy,
  label CLEAR-SCREEN-loop
    $20 # lda,
    $0400 $,y sta,
    $0500 $,y sta,
    $0600 $,y sta,
    $06e8 $,y sta,
    1   # lda, \ white
    $d800 $,y sta,
    $d900 $,y sta,
    $da00 $,y sta,
    $dae8 $,y sta,
    iny,
  CLEAR-SCREEN-top bne,

  \ Put the cursor - a reverse-video space $a0 - at $0400.
  $a0   # lda,
  $0400 $ sta,
end-code

code INIT-SCREEN
  6     # lda, \ blue
  $d020 $ sta, \ border colour
  0     # lda, \ black
  $d021 $ sta, \ background color
  CLEAR-SCREEN-top $ jmp, \ Tail call to CLEAR-SCREEN
end-code-bare


\ Keyboard ===================================================================
label forth-key-semaphore 0 asm,
label forth-key           0 asm,

code KEY ( -- key )
  1 # lda,
  forth-key-semaphore $ sta,
  label (KEY)-loop
    forth-key-semaphore $ lda, \ Spin waiting for the interrupts.
  (KEY)-loop bne,
  \ Now the key is populated.
  dex, dex,
  0         # lda,   1 zp,x sta,
  forth-key $ lda,   0 zp,x sta,
end-code


\ Main =======================================================================
REQUIRE interrupts.ft

\ Some KERNAL routines for startup.
$fda3 CONSTANT k-ioinit
$fd50 CONSTANT k-ramtas
$fd15 CONSTANT k-restor
$ff5b CONSTANT k-cint

$0314 CONSTANT irq-indirect

label debug-spin
  0 # lda,
  debug-spin beq,

\ Machine code entry point.
\ Sets up the basic system - bank switching, interrupt vectors, etc.
label main
  sei, \ No interrupts for now.
  cld, \ Just in case, no one wants decimal mode.
  $ff # ldx,
  txs,
  sp0 # ldx,

  \ TODO: See about smaller/faster setup, and maybe copying the Forth system
  \ to a lower address to make maximum contiguous memory for the dictionary.

  \ For now I'm using the kernal ROM startup routines.
  k-ioinit $ jsr,
  k-ramtas $ jsr, \ TODO: Most likely to be skippable - just set PAL/NTSC?
  k-restor $ jsr,
  k-cint   $ jsr,

  vec-irq irq-indirect w!,

  cli,  \ Interrupts are rigged up again.

  \ From this point we no longer need the BASIC or KERNAL ROMs except for IRQ.
  \ TODO: Crib the minimal interrupt-handling code from the KERNAL ROM into the
  \ Forth implementation and discard the KERNAL.

  \ On copying the entire engine to low memory?
  \ The Forth system with no application code is perhaps 12KiB.
  \ The tightest loop I can devise for copying that sort of thing is the MOVE<
  \ loop, which requires 21 cycles per byte, plus 16 per page.
  \ 12KiB is 12,288 bytes and 48 pages: 258,048 + 768 = 258,816 cycles.
  \ The NTSC clock speed is just over 1MHz, so I would expect 500ms or so.

  \ TODO: Implement this copying scheme, if it proves useful to have a large
  \ contiguous block of memory for eg. a Z-machine.

  \ TODO: VARIABLEs and other would-be writable fields are being defined inside
  \ the ROM, which is obviously not going to work. So I either need to tweak
  \ this to be ROM-friendly, load it from a disk .prg file instead, or copy it.
  \ Actually I think a disk might be better - a tiny BASIC header makes the disk
  \ program execute itself when RUN at the console. (VICE can auto-run too.)

  \ TODO: Adjust the memory banks at this point, if we're going to.

  \ Set the initial DP into the ZP slot.
  var_dp_ptr herel w!,

  \ The hardware stack starts configured - set up the data stack by setting X to $80.
  sp0 # ldx,

  \ There's no fancy FORTH initialization, IP, or NEXT with STC.
  \ Jump through the entry-point cell, which contains an xt, ie. a code address.
  entry-point $ (jmp),

\ Write this main routine into the cart's reset vector.
main $8000 t!

