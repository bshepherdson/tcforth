\ ===================== MACHINE/MODEL DEPENDENT SECTION ======================
\ DTC, TOS in register.
\ r13/sp is data stack, r14/lr is used for links.
\ r12 is IP, r11 is RSP, r10 is tos.
: ip  r12 ;
: rsp r11 ;
: tos r10 ;

\ bl docol, bl dovar, bl dodoes-code can fit into one cell.


\ Standard dictionary headers: link, length+immediate+hidden word, len words of
\ name, code field.

\ This is a little surprising, but it makes sense when you think deeper:
\ NATIVE HERE pushes the Host's dictionary pointer.
\ HOST   HERE pushes the Target's dictionary pointer
\ TARGET HERE is the mirror word that compiles the Target xt for HERE (!)
HOST DEFINITIONS


\ First line of code, the entry point. This is at $0 in code-there space, but
\ will be loaded at $10000 by the ARM runtime.
?stack-clear
code-there @ b,


\ Some assembler macros
?stack-clear
: next,    ( -- ) config instr-width @   # ip []+ pc ldr, ;
: pushrsp, ( r 0 -- ) 2>R {{ 2R> }} rsp !stmdb, ;
: poprsp,  ( r 0 -- ) 2>R {{ 2R> }} rsp !ldmia, ;

: tcompile,  ( xt -- )      tcode, ;
: tdecompile ( slot -- xt ) tcode@ ;


VARIABLE 'latest   \ Host var holding the Target nt of the last word defined.
: LATEST ( -- nt ) 'latest @ ;
0 'latest !

\ This is called with BL, so lr holds the address after the code field, which is
\ the thread.

label DOCOL
  ip pushrsp,
  lr ip mov,
  next,

\ DOVAR is the code word for a CREATEd definition without a DOES> - it pushes
\ the address of the parameter field.
\ The address of the cell after DOVAR is in lr.
\ With collocated names and data, that cell is the start of the parameter field.
\ With separated names, there's a pointer to the parameter field there.
colocated-names? [IF]
  : pfa->tos, ( -- ) lr tos mov, ;
[ELSE]
  : pfa->tos, ( -- ) lr [] tos ldr, ;
[THEN]

label DOVAR
  {{ tos }} push,
  pfa->tos,
  next,

\ DOES> design for DTC =======================================================
\ This is different from the original TC-Forth DODOES scheme.
\ Sequence 1: while eg. : CONSTANT create , DOES> @ ; is being defined.
\ Sequence 2: while CONSTANT is running, defining a new constant.
\ Sequence 3: while a particular constant is executing.

\ DOES> is an immediate word, it runs during "Sequence 1".
\ It compiles   (DOES>) EXIT dodoes-code   at the end of CONSTANT.
\ Then the Forth code after DOES> is compiled. The final CONSTANT looks like:
\ link | len | CONSTANT | bl docol | CREATE | , | (DOES>) | EXIT |
\    dodoes-code | @ | EXIT
\ Sequence 2 (eg. 7 CONSTANT FOO) CREATEs the new header with the default
\ bl DOVAR in its code field, but then (DOES>) runs and patches it to
\ bl &dodoes-code as above, ie. after the EXIT:
\ link | len | FOO | bl &dodoes-code | 7

\ With separate code and data spaces, this is rather:
\ link | len | FOO | bl &dodoes-code | data space ptr
\ and at that address in data space is the 7.

\ In DTC, the dodoes-code is entered with the parameter field (pointer to 7)
\ in lr. So the code pushes that, then does bl docol.
\ So the dodoes-code is three words.

\ This HOST word is invoked by Host-side DOES> to compile the necessary pieces.
VARIABLE '(DOES>)
VARIABLE 'EXIT   \ These get populated later.

: EXIT, ( -- ) 'EXIT @ tcompile, ;

: DOES, ( -- xt-does )
  '(DOES>) @ tcode,
  'EXIT    @ tcode,
  code-there @
  {{ tos }} push,
  pfa->tos,
  docol bl, ;


\ Not really words, just assembler routines.
\ TODO: Maybe these are better as mirror words without Target-side headers?
label LIT
  {{ tos }} push,
  4 # ip []+ tos ldr,
  next,

label DOSTRING
  {{ tos }} push, \ Push the old TOS
  \ Next byte in the thread is the length, then that many characters.
  1 # ip []+ tos ldrb, \ TOS gets the length
  {{ ip }} push,  \ Push the string c-addr
  \ IP points at the start of the string; add the length to point past it, then
  \ re-align it.
  tos ip ip add,
  3 # ip ip add,
  3 # ip ip bic,
  next,


\ Compiles the code field (address) for a colon declaration.
\ For DTC that means assembling a bl docol.
: ,docol ( -- ) docol bl, ;

\ Compiles the bl DOVAR.
: ,dovar ( -- ) dovar bl, ;

\ Compiles a string literal into the thread.
\ In ITC/DTC that's DOSTRING, then the length, then the chars.
\ NB The length is a byte, not a cell. This errors if it's too big.
: ,dostring ( c-addr u -- )
  dup 256 >= ABORT" dostring length exceeds a byte"
  dostring tcompile,
  dup tcode-c,
  ( c-addr u ) BEGIN ?dup WHILE 1- >R   dup c@ tcode-c,   1+ R> REPEAT drop
  tcode-align ;

\ Overwrites the code field (address) of the word at word-xt to point to the
\ ;CODE or DOES> at does-xt.
\ On DTC ARM, this compiles bl does-xt.
: !dodoes ( does-xt word-xt -- )
  code-there @ >R   code-there !   bl,   R> code-there ! ;

\ Compile a literal. This is in the model because eg. STC doesn't use the two-
\ cell [LIT|x] pattern.
: tliteral ( x --    X: -- x ) lit tcompile,   tcode, ;

\ For ARM the code field is always one instruction = 1 cell.
: t>pfa ( t-xt -- pf-slot ) tcell+ ;

\ Entry point at 64KB, stacks at 32MB with 2KB ($800) for the return stack.
$02000000 CONSTANT rp0
$01fff7fc CONSTANT sp0 \ Fix main if this is changed.

label entry-point 0 asm,

\ Space for : and ; ==========================================================
\ : :   (CREATE) ,docol smudge ] exit    5 cells and the codeword
: allot-: ( -- ) 6 tcells code-there +! ;
\ : ;   EXIT-compile, smudge [ exit
\ EXIT-compile, pushes: lit + xt + compile, = 3, plus smuge [ exit for 6, plus the codeword = 7
: allot-; ( -- ) 7 tcells code-there +! ;
