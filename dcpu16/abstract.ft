\ ALIGNMENT AND PORTABILITY =====================
tcode ALIGN   ;tcode \ No-op
tcode ALIGNED ;tcode \ No-op

\ Given the xt OF A COLON DEFINITION, returns its thread address.
\ NB: The code field is always 2 words, even if it's just one-word JSR DOCOL.
\ DODOES uses that second slot, and a user code field would be JSR lit
t: >BODY ( xt -- a-addr ) lit ,, 2 ,, cf_+ ,, ;t

\ Given a name token, advances it to the code field address, the xt.
t: >CFA  ( nt -- xt ) \ 1+ dup c@ mask_len and +
  cf_1+ ,, cf_DUP ,, cf_C@ ,, lit ,, mask_len ,, cf_AND ,, cf_+ ,, ;t

tcode compile, ( xt -- ) cf_, $ pc set, ;tcode-bare

\ Sets the code action of a word given its cfa.
\ Assumes the code field is only one word!
\ JSR inline-lit is   ( addr ) $21 + 10 lshift   $20 or
t: !CF ( addr cfa -- )
  \ swap $21 + 10 lshift   $20 or   swap !
  cf_SWAP ,,   lit ,, $21 ,, cf_+ ,, lit ,, 10 ,, cf_LSHIFT ,,
  lit ,, $20 ,, cf_OR ,,
  cf_SWAP ,, cf_! ,,
;t

\ !CF plus making space (1 word)
t: ,CF ( addr -- ) cf_HERE ,, cf_!CF ,,   lit ,, 1 ,,   cf_ALLOT ,, ;t

\ Shorthand to make the code field DOCOL
\ HERE points to the data area, so reach back 2 words.
t: !COLON ( -- ) \ DOCOL   HERE 2 -   !CF
  lit ,, DOCOL ,, cf_HERE ,, lit ,, 2 ,, cf_- ,, cf_!CF ,, ;t

t: ,EXIT  ( -- ) \ ['] EXIT ,XT
  lit ,, cf_EXIT ,, cf_compile, ,, ;t


\ CONTROL STRUCTURES ============================
\ These words allow Forth control structure words
\ to be defined portably.

tcode ,BRANCH  \ ( xt -- ) append a branch instruction
  \ For ITC and DTC, this is just compile,
  cf_COMPILE, # pc set,
;tcode-bare

tcode ,DEST    \ ( dest -- ) append a branch address
  \ Appends the given destination address here.
  \ On the DCPU-16, which uses absolute branches, this is just ,
  cf_, # pc set,
;tcode-bare

tcode !DEST    \ ( dest adrs -- ) Change the branch destination at adrs to dest
  \ On the DCPU-16 with absolute branches, this is just !
  cf_! # pc set,
;tcode-bare


\ \ HOST CONTROL STRUCTURES ========================
\ \ There are HOST words to help hand-roll threads for this target.
\ : if, ( -- t-addr-slot    assembles 0branch and empty slot )
\   cf_(0BRANCH) ,, there @ 0 ,, ;
\ : then, ( t-addr-slot -- ) there @ swap w! ;
\ : else, ( if-slot -- else-slot )
\   cf_(BRANCH) ,, there @ 0 ,,   swap   ( else if ) there @ swap w! ( else ) ;
\ 
\ : begin, ( -- top-loc ) there @ ;
\ : while, ( -- while-slot    assembles 0 branch ) if, ;
\ : again, ( top-loc -- ) cf_(BRANCH) ,, ,, ;
\ : repeat, ( top-loc while-slot -- ) swap again, then, ;

