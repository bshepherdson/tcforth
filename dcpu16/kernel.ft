\ Kernel for the DCPU-16.
\ This file runs in the HOST vocabulary, assembling CODE words into the target.
\ We attempt to use macros from model.ft (already loaded) to hide details of
\ the system design.

\ Assembler abstractions:
\ - rsp is the return stack pointer itself
\ - [rsp] is RSP's TOS
\ - ip is the current IP address
\ - [ip] the value found at IP.

\ Assumptions in this code:
\ - Using the DCPU-16 hardware SP as Forth's data stack.
\ - TOS on stack.
\ - A B C X Y are free.
\ - J is reserved. No STI/STD.

\ Standard dictionary headers: link, length+immediate+hidden word, len words of
\ name, code field.

code +        pop peek add,   end-code
code -        pop peek sub,   end-code \ This is correct NOS - TOS order!
code *        pop peek mli,   end-code
code -        pop peek sub,   end-code
code /        pop peek dvi,   end-code
code MOD      pop peek mdi,   end-code
code U/       pop peek div,   end-code
code UMOD     pop peek mod,   end-code
code AND      pop peek and,   end-code
code OR       pop peek bor,   end-code
code XOR      pop peek xor,   end-code
code LSHIFT   pop peek shl,   end-code
code RSHIFT   pop peek shr,   end-code
code ARSHIFT  pop peek asr,   end-code

code INVERT   $ffff # peek xor, end-code
code NEGATE
  0 # ra set,
  pop ra sub,
  ra push set,
end-code

\ Comparison operators all have the same shape with different branches.
: comparison ( if-xt "name" -- )
  >R
  code
    0 # ra set,
    pop pop   R> execute
      -1 # ra set,
    ra push set,
  end-code
;

' ife, comparison =
' ifu, comparison <
' ifl, comparison U<


\ Stack operations
code DUP    peek   push set,  end-code
code DROP   pop    ra   set,  end-code
code OVER   1 picc push set,  end-code

code SWAP
  pop  ra   set,
  pop  rb   set,
  ra   push set,
  rb   push set,
end-code

code ROT ( c b a -- b a c )
  pop  ra   set,
  pop  rb   set,
  pop  rc   set,
  rb   push set,
  ra   push set,
  rc   push set,
end-code

code -ROT ( c b a -- a c b )
  pop  ra   set,
  pop  rb   set,
  pop  rc   set,
  ra   push set,
  rc   push set,
  rb   push set,
end-code

code ?DUP
  0 # peek ifn,
    peek push set,
end-code

code NIP ( y x -- x )
  pop ra   set,
  ra  peek set,
end-code


code SP@
  sp ra   set,
  ra push set,
end-code

code RP@   rz push set,   end-code

code >R    pop  pushrsp,   end-code
code R>    push poprsp,    end-code
code R@    [z]  push set,  end-code

code DEPTH
  sp0 # ra set,
  sp    ra sub,
  ra  push set,
end-code


code @
  pop  ra   set,
  [a]  push set,
end-code

code !
  pop  ra  set,
  pop  [a] set,
end-code

\ These are identical to @ and ! in DCPU-16.
code C@
  pop  ra   set,
  [a]  push set,
end-code

code C!
  pop  ra  set,
  pop  [a] set,
end-code

\ These store as hi, lo in memory, but push as ( lo hi ) double-words.
code 2@
  pop    ra   set,
  1 [a+] push set,
  [a]    push set,
end-code

code 2!
  pop    ra   set,
  pop    [a]  set,
  pop  1 [a+] set,
end-code

code +!
  pop ra  set,
  pop [a] add,
end-code


\ Leaves I alone. Jump directly into the target's code field.
\ The EXECUTEd word's NEXT will continue after here (eventually).
code EXECUTE
  pop pc set,
end-code-bare



label var_dp          0 asm,
label var_latest      0 asm,
label var_state       0 asm,
label var_source      0 asm, 0 asm,
label var_in_ptr      0 asm,
label var_source_id   0 asm,
label input-buf       128 there +!

code DP
  var_dp # push set,
end-code

code ,
  var_dp  # rb  set,
  [b]       rc  set,
  pop       [c] set,
  1 #       [b] add,
end-code

code 'LATEST      var_latest # push set, end-code
code STATE        var_state  # push set, end-code
code 'SOURCE      var_source # push set, end-code
code 'SOURCE-ID   var_source # push set, end-code
code >IN          var_in_ptr # push set, end-code
code TIB          input-buf  # push set, end-code


code 2DUP
  1 picc push set,
  1 picc push set,
end-code

code 2DROP
  2 # sp add,
end-code

code 2SWAP ( x c b a -- b a x c )
  pop   ra   set,
  pop   rb   set,
  pop   rc   set,
  pop   rx   set,
  rb    push set,
  ra    push set,
  rx    push set,
  rc    push set,
end-code

code 2OVER
  3 picc push set,
  3 picc push set,
end-code


code 1+      1 # peek add,   end-code
code CELL+   1 # peek add,   end-code
code CHAR+   1 # peek add,   end-code
code 1-      1 # peek sub,   end-code

\ These are no-ops
code CELLS   end-code
code CHARS   end-code

code CELL   1 # push set,   end-code


\ Double-cell arithmetic
\ TODO 123. double-cell conversion in the >NUMBER interpreter
code S>D
  0 #     ra   set,
  $8000 # peek ifb, \ Bit in common
    -1  # ra   set,
  ra   push  set,
end-code

\ D>S is DROP
code D>S   1 # sp add,  end-code

code D+  ( l1 h1 l2 h2 -- l3 h3 )
  pop  rb     set, \ h2
  pop  ra     set, \ l2
  ra   1 picc add, \ l1+l2    -> l3, EX
  rb   peek   adx, \ h1+h2+EX -> h3
end-code

code D-  ( l1 h1 l2 h2 -- l3 h3 )
  pop  rb     set, \ h2
  pop  ra     set, \ l2
  ra   1 picc sub, \ l1-l2    -> l3, EX
  rb   peek   sbx, \ h1-h2+EX -> h3
end-code

\ TODO More double-cell arithmetic


\ Branches are abstracted, because they differ signficantly on STC systems,
\ and even on others they might prefer relative or absolute branches.
\ ,BRANCH ,DEST and !DEST handle that abstraction between the kernel and the
\ shared high-level Forth control structures.

\ On the DCPU, these are absolute new I values in the next slot of the thread.
code (BRANCH)
  ip <[ip]+,
end-code

code (0BRANCH)
  ra <[ip]+,   \ IP advanced; A holds the optional target.
  0 # pop ife,
    ra ip set, \ Branch passed, so set IP to the target.
end-code


code EXIT
  \ Get the target XT for EXIT and stash it in the forward reference.
  here 'EXIT !

  ip poprsp,
end-code

\ Converts a name token (ie. a hdr pointer) into the code field address, by
\ skipping over the name.
code >CFA ( nt -- xt )
  pop        ra   set, \ A is the NT
  1 [a+]     rb   set,
  mask_len # rb   and, \ B now the length
  2 #        ra   add,
  rb         ra   add, \ A is now the CFA
  ra         push set,
end-code

\ A jsr docol for reference.
label jsr_docol   docol # jsr,

\ Compiles a jsr docol into the current definition.
code ,DOCOL ( -- )
  var_dp    [#] ra  set, \ A is DP
  jsr_docol [#] [a] set, \ Store the jsr docol at [A]: the current HERE.
  1 #   var_dp  [#] add, \ Update the DP
end-code


