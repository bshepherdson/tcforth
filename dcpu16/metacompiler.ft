\ Kernel (layer 1) for the DCPU-16.
\ This is a host Forth file that depends on the ANS Forth assembler for DCPU-16.

\ Design:
\ - Direct threading
\ - Return stack: RSP in Z; top 128 cells of memory, $ff80 to $ffff.
\ - Data stack: PSP is SP; TOS on stack (PUSH, PEEK etc. are super fast)
\ - IP is I (so STI can be used in NEXT)
\ - A B C X Y are free; J is reserved (it gets clobbered by STI)
\   - (No STI, STD aside from that use.)

\ Standard dictionary headers: link, length+immediate+hidden word, len words of
\ name, code field.

\ This is a little surprising, but it makes sense when you think deeper:
\ NATIVE HERE pushes the Host's dictionary pointer.
\ HOST   HERE pushes the Target's dictionary pointer
\ TARGET HERE is the mirror word that compiles the Target xt for HERE (!)
HOST DEFINITIONS

\ The assembler defines a THERE pointer for the Target dictionary.
\ We capture that address as the HOST DP as well.
there CONSTANT DP
: here dp @ ;
0 dp !   \ DCPU execution starts at $0000 by default.

: t,        ( w -- )  asm, ;
: tc,       ( b -- )  asm, ;   \ Byte-width assemble. That's just t, here.
: tc@ t@ ;
: tc! t! ;
: tallot dp +! ;

VARIABLE 'latest   \ Host var holding the Target nt of the last word defined.
: LATEST ( -- nt ) 'latest @ ;
0 'latest !

\ Controls whether headers are created by (TCREATE); some definitions are
\ headless.
VARIABLE ?heads   0 ?heads !


\ First line of code, the entry point. Jump to COLD.
$8000 # pc set, \ Forcing a two-word jump. The target will be adjusted later.


\ ===================== MACHINE/MODEL DEPENDENT SECTION ======================
\ Trying to keep the system as portable across both machines and Forth models
\ as possible. model.ft implements a few key routines (eg. DOCOL) and assembler
\ macros (eg. pushrsp,) to hide the details of the model as much as possible.
REQUIRE model.ft

HOST DEFINITIONS

: t>cfa ( target-nt -- target-xt ) tcell+ dup t@ mask_len and + tcell+ ;


\ =========================== MIRROR WORDS ===================================
\ The mirror words go in the TARGET vocabulary, the one that's active while
\ metacompiling the target application.
\ There are several points to note that drive the design:

\ First, there are *four* actions for each word, some of which have defaults:
\ - When executed by the target.
\ - When compiled by the target.
\ - When executed by the metacompiler
\ - When compiled by the metacompiler

\ Note that the metacompiler leaves the hosting Forth in "interpreting" STATE
\ (ie. NATIVE STATE) throughout. However, the metacompiler has a separate STATE,
\ controlling whether it is "metacompiling" or "metainterpreting". This is
\ HOST STATE.

\ Regular words (eg. DUP) can have defaults fill in three of the actions:
\ - Target exec: TARGET DEFINITIONS HOST CODE DUP some asm code, END-CODE
\ - Target compile: compile the xt, the default for non-IMMEDIATE words.
\ - Host exec: Throw an error - can't execute regular Target words.
\ - Host compile: compile the Target xt into the image
\   - This is the default action of mirror words; their raison d'etre.

\ IMMEDIATE words (eg. IF) work like this:
\ - Target exec: (undefined, probably throw an error via ?comp)
\ - Target compile: run immediately, compile 0branch and a target.
\ - Host exec: Throw an error also.
\ - Host compile: Run a Host-side action, compiling TARGET 0BRANCH and the dest
\     just like Target compiling.
\ This is achieved with HOST ACTS: ... ; IMPERATIVE

\ Defining words (eg. CONSTANT) that use DOES> are yet more complex.
\ See DESIGN.md for the details.
HOST
VARIABLE STATE
VARIABLE 'mirror \ Holds the body address of the last mirror word defined.
VARIABLE >mirror \ Holds the body address of the mirror currently executing.
                 \ This is used by mirror-compile, and mostly ignored otherwise.

: interpX ( addr -- )
  drop 1 ABORT" Can't interpret TARGET word without HOST ACTS:" ;
: interpX-imperative ( addr -- )
  drop 1 ABORT" Can't interpret IMPERATIVE mirror word" ;
: doesX-blank ( addr -- )
  drop 1 ABORT" No DOES> action defined for this mirror word" ;

: mirror-compile ( -- ) >mirror @ @ dup ." compiling " hex. cr T, ;

: mirror>txt       ( mirror-body -- 'target-xt )       ;
: mirror>interp    ( mirror-body -- 'interp-xt )       cell+ ;
: mirror>compile   ( mirror-body -- 'compile-xt )      2 cells + ;
: mirror>h-does    ( mirror-body -- 'host-does-xt  )   3 cells + ;
: mirror>t-does    ( mirror-body -- 'target-does-xt )  4 cells + ;
: mirror>mirror-nt ( mirror-body -- 'mirror-nt )       5 cells + ;

\ The parameter field of a mirror word contains:
\ Target xt, metainterpreting xt, metacompiling xt, Host DOES> xt, Target DOES> xt
: mirror ( target-xt "name" -- )
    CREATE
    native   dup hex. latest name>string type cr   here   host 'mirror !
    ( target-xt ) ,   ['] interpX ,   ['] mirror-compile ,
    ['] doesX-blank ,   0 ,
    native latest host ,
  DOES>
    dup mirror>mirror-nt @ id.
    dup >mirror !
    STATE @ ( mirror-body meta-state ) IF
      mirror>compile
    ELSE
      mirror>interp
    THEN @ execute ;

\ Creates a new, bare dictionary entry on the Target, and its mirror word in the
\ TARGET vocabulary! They both have the same name.
\ Leaves the vocabulary set to HOST.
: (TCREATE) ( "name" -- )
  \ Create the Target header first, so we have its xt.
  \ But save the input pointer so we can hoik the name again.
  >IN @ >R
  parse-name ( c-addr u ) (mk-header)  ( xt )
  R> >IN !   \ Input pointer is aimed at the name again.
  \ Set up compilation into the TARGET vocabulary, but without switching to
  \ looking words up in it.
  get-current >R   target-wl set-current
  mirror
  R> set-current \ And back.
;

host definitions

\ These are HOST vocab words that define assembler words on the Target - their
\ mirror words are regular.
: code      ( "name" -- ) (TCREATE) ;
: end-code  ( -- )        next, ;
\ End marker, but no NEXT.
: end-code-bare ( -- ) ;


\ Now we have what we need to metacompile the CODE definitions at the heart of
\ the new kernel.
REQUIRE kernel.ft
host

\ Overwrite the jump target of the entry code to be main.
\ The instruction is at $0000 and its target argument at $0001.
main 1 t!


\ Metacompiling Forth words ==================================================
\ In the TARGET vocab, : creates a new definition with codeword, in both HOST
\ and TARGET, just like HOST CODE.

\ It switches the *metacompiler* to compiling state, but not the Host's own
\ compiler. Therefore the words in the definition will be executed by the host,
\ rather than compiled. These are the mirror words, and executing them compiles
\ themselves into the Target.

\ Replacement parser for the target "compiler", runs during colon definitions.
\ This is a normal compiler. The regular one would have worked except for two
\ things: (1) HOST STATE is not NATIVE STATE; (2) capturing numbers.
: meta] ( -- )
  \ ." top of meta] " .s cr
  1 state ! \ Start off in the metacompiling state.
  BEGIN state @ WHILE
    parse-name ?dup IF ( c-addr u )
      2dup find-name ( ca u nt|0 ) ?dup IF
        \ Found it. Execute the target word.
        >R 2drop R> name>int ( ." Before: " .s ) execute ( ."    after: " .s cr)
      ELSE ( ca u )
        2dup s>number? IF ( ca u d )
          D>S >R 2drop R> ( n ) LIT T, T,
        ELSE
          2drop 2drop
        THEN ( )
      THEN ( )
    ELSE ( c-addr ) refill 2drop THEN ( )
  REPEAT \ ." end of meta]" .s cr
  ;


: (T') ( "name" -- mirror-body )
  parse-name target-wl search-wordlist IF >body ELSE 1 ABORT" Bad T'" THEN ;
: T' ( "name" -- target-xt ) (T') mirror>txt @ ;
: [T'] ( C: "name" --    X: -- target-xt ) T' postpone literal ; IMMEDIATE


\ Bootstrapping the : for use by the target. It needs to (TCREATE) and compile
\ jsr docol in the target, then activate the ] parser.
\ These need their host and target sides defined.
\ START HERE: This is a tricky bootstrapping problem. Probably make a host-only
\ : and ; and then replace them later with the target-side equivalents once
\ eg. CREATE is defined on the target?
\ Forward references are one path, or I can just leave a few blank words in the
\ target's : and fill them in later.

\ Runs in the HOST. Replaces the metainterpretation action for the most-recent
\ mirror word.
\ Use IMPERATIVE to make this the metacompilation action instead.
VARIABLE acting?   VARIABLE doing?
: ACTS: ( --    X: -- ) acting? on   :noname ;
\ Makes the interp action of the latest mirror word exactly a host word.
: ACT   ( "name" -- )
  parse-name find-name name?int   'mirror @ mirror>interp ! ;


\ Like IMMEDIATE for metacompilation - copies the metainterpretation action to
\ be the metacompilation action instead, and makes the metainterpretation action
\ an error.
: IMPERATIVE ( -- )
  'mirror @ dup >R  ( mirror     R: mirror )
  mirror>interp @   R@ mirror>compile !
  ['] interpX-imperative   R> mirror>interp !   ;


\ Regular semicolon, plus check acting? and doing? and update the 'mirror word.
: ;
  native postpone ; host
  acting? @ IF acting? off   ( xt ) 'mirror @ mirror>interp ! EXIT THEN
  doing?  @ IF doing?  off   ( xt ) 'mirror @ mirror>h-does ." doing? " over hex. dup hex. cr ! EXIT THEN
; IMMEDIATE


host definitions
T' (0BRANCH) CONSTANT T0BRANCH
T' (BRANCH)  CONSTANT TBRANCH
T' DROP      CONSTANT TDROP
T' OVER      CONSTANT TOVER
T' =         CONSTANT T=


\ Some host-side actions for CODE words, like @ and !
'mirror @
(T') @ 'mirror !   act t@
(T') ! 'mirror !   act t!
'mirror !

\ Hand-roll the target+mirror definitions for : and ;
\ They don't work on the target yet, just making space.
target definitions host
code : end-code 0 t, 0 t, 0 t, 0 t,
  host acts: ." host :" cr (TCREATE)   ,docol   meta] ;

code ; end-code 0 t, 0 t, 0 t, 0 t,
  host acts: 0 state !   'EXIT @ tcompile, ; IMPERATIVE


host here ." Metacompilation starts at " dup hex.  ." (" 2* hex. ." )" cr

host .s cr
REQUIRE ../shared/core1.ft

\ entry-point should now be set properly for the :main routine.
