\ Defines the format of Target dictionary headers.
\ Uses abstracted words like TC@ and TCELL+ so it should work on any Target.
host definitions

\ Header structure ===========================================================
\ Each header is a variable-length block like this:
\ Start       Contents                 Size
\ 0           link pointer             1 cell
\ 1c          length byte              1 unit
\ 1c+1u       name characters          1 unit per character (L characters)
\ 1c+(1+L)u   (blank space)            0 to 1c-1u, enough to align.
\ kc          code field               ...

\ So for example, on a byte-addressable 32-bit machine with 4-byte alignment:
\ 0           $1234                    1 cell (4 bytes)
\ 4           Length 5                 1 byte
\ 5           First char F             1 byte
\ 6           First char O             1 byte
\ 7           First char R             1 byte
\ 8           First char T             1 byte
\ 9           First char H             1 byte
\ 10          (blank for alignment)    2 bytes
\ 12          code field

\ On a machine with 16-bit address units and cells, like DCPU-16, every field
\ is a 16-bit word and no alignment is needed.

\ First the header and length. The top bit is used for IMMEDIATE, the next for
\ smudge, the rest for length. That gives a length of 63 characters if the width
\ is 8 bits.
1   config char-bits @ 1- lshift CONSTANT f_immed
f_immed  1 rshift  CONSTANT f_hidden
f_immed  1-        CONSTANT mask_len_hidden
f_hidden 1-        CONSTANT mask_len


\ Compiles a fresh Target header with an empty code field.
\ This is a bit tricky with split spaces: the linked list and name of the word
\ is in name space; the xt is in code space.
colocated-names? [IF]
  \ Names, code and data are commingled, so no indirection is needed.
  \ The xt of a definition is right after it.
  : <mk-code-field> ( -- target-xt ) here ;
[ELSE]
  \ When name and code are separated, the name space has a pointer to the code
  \ space for this word. (Note that even VARIABLEs and CREATEd defs exist in
  \ code space; with separated code and data they have a pointer to their data.
  : <mk-code-field> ( -- target-xt ) code-there @   dup tname, ;
[THEN]

: (mk-header) ( c-addr u -- target-xt )
  \ ." (mk-header) " 2dup type   4 spaces .s cr
  name-there @   latest tname,   'latest !
  dup tname-c, \ Length byte
  0 DO ( c-addr ) dup i + c@ >upper tname-c, LOOP drop ( )
  name-there @   taligned   name-there !
  <mk-code-field> ;

: t>cfa ( target-nt -- target-xt )
  tcell+ dup tcode-c@ mask_len and + tchar+ taligned ;

: TNAME>STRING ( t-nt -- c-addr u ) tcell+ dup 1+ swap tcode-c@ mask_len and ;

\ Single dictionary builds the word just follows.
: TNAME>INT ( t-nt -- t-xt ) tname>string + taligned ;

\ If names and code are NOT colocated, wrap the above words to indirect through
\ the name space pointers into code space.
colocated-names? 0= [IF]
  : t>cfa ( target-nt -- target-xt ) t>cfa tname@ ;
  : TNAME>INT   tname>int tname@ ;
[THEN]

: T>NAME ( target-xt -- target-nt|0 )
  'latest @ BEGIN dup WHILE ( target-xt target-nt )
    2dup tname>int = IF nip EXIT THEN
    tname@
  REPEAT nip ;

: TTYPE ( tc-addr u -- ) over + swap ?DO i tname-c@ emit LOOP ;

: TID. ( t-nt -- ) tname>string ttype ;
