\ Sets up the three dictionary spaces for the assembler and metacompiler.

\ The Forth dictionary is divided into three parts:
\ - Code space, where native code and read-only data goes.
\ - Name space, where the names and dictionary data structure goes.
\ - Data space, where writable data goes.

\ These spaces might overlap, as in traditional Forths. But they might not!
\ Note that the data space is not part of the binary and needs to be
\ initialized by the setup code.
\ See host/configuration.ft for the flags that control this setup.

\ Each space is captured by a THERE-PTR array, which looks like this:
\ [ there | max-there | host-ptr | org | file-offset ]
\ there       reckoned in the target address space; tcode-addr etc. to adjust
\ max-there   the largest THERE value ever used
\ host-ptr    host pointer to where its actually being assembled; indexed from 0
\ org         target address space point where the *start* of this range is found
\ file-offset offset into the output file where this belongs

\ To actually look up a byte from the space:
\ - org is subtracted from it, creating a 0-based offset into the space
\ - then that offset is used for the host-ptr to get the real value

\ Allocates 8MB on the host heap.
: new-space ( -- host-addr ) 8 1024 * 1024 * allocate drop ;

\ Creates a new THERE-PTR array, with the specified host-ptr.
\ Sets THERE, ORG and file-offset all to 0; these should be customized by
\ target-specified code as needed. Use ORG! to set these.
: there-ptr ( host-space   "name" --   X: -- there-array )
  \      there | host-ptr | max-host | org | file-offset
  CREATE 0 ,     dup ,      ,          0 ,   0 , ;


\ Define all three spaces, per the configuration flags.
\ code-space always exists for real, so start there.
new-space THERE-PTR code-there

\ Name space always exists at least in the metacompiler.
\ So even if it won't reach the output file, create it.
config mix-code-and-name? @ [IF]
  code-there CONSTANT name-there
[ELSE]
  new-space THERE-PTR name-there
[THEN]

\ Finally, data space also always exists in the metacompiler.
\ It might or might not be shared with the code space.
config mix-code-and-data? @ [IF]
  code-there CONSTANT data-there
[ELSE]
  new-space THERE-PTR data-there
[THEN]

: space>host-array cell+ ;
: space>max        2 cells + ;
: space>org        3 cells + ;
: space>offset     4 cells + ;

\ Moves both THERE and ORG (the target pointers) to the given target-addr.
: org! ( target-addr there-array -- )
  2dup !   space>org ! ;


\ Read and Write helpers =====================================================
: bits/tcell  ( -- u ) config cell-width @   config char-bits @ * ;
: chars/tcell ( -- u ) bits/tcell   3 rshift ;
: chars/tchar ( -- u ) config char-bits @   3 rshift ;
: tchar-mask  ( -- u-mask ) 1   config char-bits @ lshift   1- ;

: +max ( host-addr there-array -- )
  space>max dup >R   @ max   R> ! ;

: taddr->offset ( target-addr there-array -- target-offset )
  space>org @ - ;
: toffset->hoffset ( target-offset -- host-offset ) chars/tchar * ;
: hoffset->haddr   ( host-offset there-array -- host-addr )
  space>host-array @ + ;

: >space ( target-addr there-array -- host-addr )
  \ cr cr ." =====================================" cr
  \ dup .space
  \ ." Target address: " over hex. cr
  dup >R            ( target-addr there-array    R: there-array )
  taddr->offset
  toffset->hoffset
  R@ hoffset->haddr ( host-addr   R: there-array )
  dup R> +max
  \ ."   Host address: " dup hex. cr
;


\ Reading internals ==========================================================
\ We want this to work for any size of char and cell on the target even if
\ it's larger or smaller than the host.
\ Note that we do require a target's char-bits to be divisible by 8!

: <t@-le> ( c-addr width -- w )
  0 swap
  0 DO ( c-addr x )
    over c@   i 8 * lshift   or ( c-addr x' )
    >R char+ R>
  LOOP nip ;

: <t@-be> ( c-addr width -- w )
  0 swap
  0   DO ( c-addr x )
    8 lshift   over c@ or   ( c-addr x' )
    >R char+ R>
  LOOP nip ;

\ TODO: It would be faster to have a DEFER'd word rather than checking
\ endianness on every read/write. Maybe a trampoline, where the DEFER starts
\ with a word that checks and resets itself.

: <t@-endian> ( c-addr width -- w )
  config little-endian? @ IF <t@-le> ELSE <t@-be> THEN ;
: <t@>  ( c-addr -- w ) chars/tcell <t@-endian> ;
: <tc@> ( c-addr -- b ) chars/tchar <t@-endian> ;


\ Writing internals ==========================================================
: <t!-le> ( w c-addr depth -- )
  0 DO ( w c-addr )
    over $ff and   over c! ( w c-addr )
    1+ >R   8 rshift   R>
  LOOP 2drop ;

: <be-bytes> ( w depth -- lsb ... msb )
  >R   dup $ff and   swap 8 rshift   R> ( lsb shifted depth )
  1- ?dup IF recurse ELSE drop THEN ;

: <t!-be> ( w c-addr depth -- )
  swap >R dup >R     ( w depth       R: c-addr depth )
  <be-bytes>         ( lsb ... msb   R: c-addr depth )
  R> R> swap 0 DO ( bytes... c-addr )
    tuck c!   char+
  LOOP drop ;

: <t!-endian> ( w c-addr depth -- )
  config little-endian? @ IF <t!-le> ELSE <t!-be> THEN ;

\ TODO: These don't handle inside-out endianness - does that include Mocha86k?
\ I think it actually does. To be fixed, then.
: <t!>  ( w c-addr -- ) chars/tcell <t!-endian> ;
: <tc!> ( b c-addr -- ) chars/tchar <t!-endian> ;


\ Reading ====================================================================
: tname@   ( t-addr -- w ) name-there >space <t@> ;
: tcode@   ( t-addr -- w ) code-there >space <t@> ;
: tdata@   ( t-addr -- w ) data-there >space <t@> ;

: tname-c@ ( t-addr -- b ) name-there >space <tc@> ;
: tcode-c@ ( t-addr -- b ) code-there >space <tc@> ;
: tdata-c@ ( t-addr -- b ) data-there >space <tc@> ;

\ Writing ====================================================================
: tname!   ( w t-addr -- ) name-there >space <t!> ;
: tcode!   ( w t-addr -- ) code-there >space <t!> ;
: tdata!   ( w t-addr -- ) data-there >space <t!> ;

: tname-c! ( b t-addr -- ) name-there >space <tc!> ;
: tcode-c! ( b t-addr -- ) code-there >space <tc!> ;
: tdata-c! ( b t-addr -- ) data-there >space <tc!> ;

\ Allot and compile ==========================================================
: <t-allot> ( u thread-ptr -- ) tuck +!   dup @ 1- swap >space drop ;

: tname-allot ( u -- ) name-there <t-allot> ;
: tcode-allot ( u -- ) code-there <t-allot> ;
: tdata-allot ( u -- ) data-there <t-allot> ;

: space>there ( thread-ptr -- host-addr ) dup @ swap >space ;

: <t,> ( w thread-ptr -- )
  tuck   space>there   <t!>
  config cell-width @   swap <t-allot> ;

: tname,   ( w -- ) name-there <t,> ;
: tcode,   ( w -- ) code-there <t,> ;
: tdata,   ( w -- ) data-there <t,> ;

: <tc,> ( w thread-ptr -- )
  tuck   space>there <tc!>
  1 swap <t-allot> ;

: tname-c, ( w -- ) name-there <tc,> ;
: tcode-c, ( w -- ) code-there <tc,> ;
: tdata-c, ( w -- ) data-there <tc,> ;


\ Extras =====================================================================
: TVARIABLE ( "name" --    X: -- t-addr )
  data-there @   config cell-width @ tdata-allot   CONSTANT ;


\ File output ================================================================
: extend-file ( offset file -- )
  \ ." Extend-file offset: " over hex. ." file: " dup hex. cr
  >R s>d
  2dup R@ resize-file       ABORT" failed to resize file"
       R> reposition-file   ABORT" failed to reposition file" ;


: .space ( there-array -- )
  ." Space:" cr
  ." Current: " dup @ hex. cr
  ." Host:    " dup space>host-array @ hex. cr
  ." Max:     " dup space>max @ hex. cr
  ." Target:  " dup space>org @ hex. cr
  ." File:    "     space>offset @ hex. cr ;

: space>span ( there-array -- c-addr u )
  dup  space>host-array @
  swap space>max @
  over - ;

: dump-space ( there-array file -- )
  \ ." dump-space: " over hex. dup hex. .s cr
  \ over .space
  >R
  dup space>offset @   R@ extend-file
  space>span
  \ ." Host span: " over hex. dup hex. cr
  R> write-file ABORT" Failed to write file" ;

: dump ( c-addr u -- )
  cr cr ." Assembling to " 2dup type cr
  W/O BIN create-file ABORT" Failed to open output file" ( file )

  \ Write the single space that we use.
  code-there over dump-space
  config mix-code-and-data? @ 0= IF data-there over dump-space THEN
  config mix-code-and-name? @ 0= IF name-there over dump-space THEN

  \ And close the file.
  dup flush-file ABORT" Failed to flush"
      close-file ABORT" Failed to close" ;
