\ Sets up the three dictionary spaces for the assembler and metacompiler.

\ The Forth dictionary is divided into three parts:
\ - Code space, where native code and read-only data goes.
\ - Name space, where the names and dictionary data structure goes.
\ - Data space, where writable data goes.

\ These spaces might overlap, as in traditional Forths. But they might not!
\ Note that the data space is not part of the binary and needs to be
\ initialized by the setup code.
\ See host/configuration.ft for the flags that control this setup.

\ Each space is captured by a THERE-PTR array, which looks like this:
\ [ there | max-there | host-ptr | org | file-offset ]
\ there       reckoned in the target address space; tcode-addr etc. to adjust
\ max-there   the largest THERE value ever used
\ host-ptr    host pointer to where its actually being assembled; indexed from 0
\ org         target address space point where the *start* of this range is found
\ file-offset offset into the output file where this belongs

\ To actually look up a byte from the space:
\ - org is subtracted from it, creating a 0-based offset into the space
\ - then that offset is used for the host-ptr to get the real value

REQUIRE configuration.ft

\ Allocates 8MB on the host heap.
: new-space ( -- host-addr ) 8 1024 * 1024 * allocate drop ;

VARIABLE all-spaces   0 all-spaces !

begin-structure [space]
  field: space>ptr
  field: space>host-array
  field: space>max
  field: space>org
  field: space>offset
  field: space>next
end-structure


\ Creates a new THERE-PTR array, with the specified host-ptr.
\ Sets THERE, ORG and file-offset all to 0; these should be customized by
\ target-specified code as needed. Use ORG! to set these.
: there-ptr ( host-space   "name" --   X: -- there-array )
  CREATE here >R   [space] allot
  dup R@ space>host-array  !
      R@ space>max         !
  0   R@ space>ptr         !
  0   R@ space>org         !
  0   R@ space>offset      !
  all-spaces @ R@ space>next !
  R> all-spaces ! ;


\ Define all three spaces, per the configuration flags.
\ code-space always exists for real, so start there.
new-space THERE-PTR code-there

\ Name space always exists at least in the metacompiler.
\ So even if it won't reach the output file, create it.
config mix-code-and-name? @ [IF]
  S" Name space is: one with code space" type cr
  code-there CONSTANT name-there
[ELSE]
  S" Name space is: separate" type cr
  new-space THERE-PTR name-there
[THEN]

\ Finally, data space also always exists in the metacompiler.
\ It might or might not be shared with the code space.
config mix-code-and-data? @ [IF]
  S" Data space is: one with code space" type cr
  code-there CONSTANT data-there
[ELSE]
  S" Data space is: separate" type cr
  new-space THERE-PTR data-there
[THEN]

\ Moves both THERE and ORG (the target pointers) to the given target-addr.
: org! ( target-addr there-array -- )
  2dup !   space>org ! ;


\ Read and Write helpers =====================================================
0 VALUE current-space

: max! ( x addr -- ) tuck @ max swap ! ;
: +max ( host-addr -- )
  \ dup   current-space space>host-array @   - $2800 > IF 99 throw THEN
  current-space space>max max! ;

: taddr->offset ( target-addr there-array -- target-offset )
  space>org @ - ;
: toffset->hoffset ( target-offset -- host-offset ) bytes/tchar * ;
: hoffset->haddr   ( host-offset there-array -- host-addr )
  space>host-array @ + ;

: >space ( target-addr there-array -- host-addr )
  \ 2dup space>org @ - $2800 > IF 98 throw THEN
  tuck                ( there-array target-addr there-array )
  taddr->offset
  toffset->hoffset
  swap hoffset->haddr ;


\ New read/write logic =======================================================
\ Using the data stack and recursing to make the pieces relative is smart, I think.
\ Also calling from tchars to literal bytes at the same time.
\ The net result is a series of tchars on the stack.

\ 1+ bytes <-> tchar on the stack
\ tchars in order on the stack, first on top <-> tcell on the stack.
: mask ( width -- mask ) 1 swap lshift 1- ;

: <c@> ( c-addr -- b ) dup +max   c@ ;
: <c!> ( b c-addr -- ) dup +max   c! ;

\ Must be supplied as part of the configuration.
\ These must use <c@> and <c!> - they do some "spaces" bookkeeping.
DEFER <tc@*> ( c-addr -- tchar )
DEFER <tc!*> ( tchar c-addr -- )

\ Default implementation is bytes.
' <c@> IS <tc@*>
' <c!> IS <tc!*>

\ DCPU-16 family uses these: big-endian 16-bit words as the address unit.
: <be16@> ( c-addr -- w ) dup <c@> 8 lshift   swap char+ <c@> or ;
: <be16!> ( w c-addr -- ) over 8 rshift over <c!>   char+ <c!> ;


\ These are all based on tchars, so they should work for any tcell size.
: <tchars@> ( c-addr #tchars -- first .. last )
  0 DO dup <tc@*>    swap bytes/tchar + LOOP drop ;

: <tchars!> ( last .. first c-addr #tchars -- )
  0 DO tuck <tc!*>   bytes/tchar + LOOP drop ;

\ These translate between the stacked tchars of the above and unified tcells,
\ depending on the order of the tchars within each tcell.
: <be@> ( c-addr -- value )
  1 tcells <tchars@> ( msc .. lsc )
  0   1 tcells 0 DO swap   tcharbits i * lshift   or LOOP ;

: <be!>  ( value c-addr -- )
  >R 1 tcells 0 DO
    dup tchar-mask and
    swap tcharbits rshift
  LOOP drop ( lsc..msc )
  R> 1 tcells <tchars!> ;


: <le@> ( c-addr -- value )
  1 tcells <tchars@>   ( lsc .. msc )
  0   1 tcells 0 DO tcharbits lshift   or LOOP ;

: <le!> ( value c-addr -- )
  >R   0 1 tcells 1- DO
    dup tcharbits i * rshift tchar-mask and
    swap
  -1 +LOOP drop ( msc .. lsc )
  R> 1 tcells <tchars!> ;


: <t@*> ( c-addr -- tcell ) config little-endian? @ IF <le@> ELSE <be@> THEN ;
: <t!*> ( tcell c-addr -- ) config little-endian? @ IF <le!> ELSE <be!> THEN ;

\ API - Explicit space =======================================================
: <tc@> ( target-addr space -- tchar ) dup TO current-space   >space <tc@*> ;
: <tc!> ( tchar target-addr space -- ) dup TO current-space   >space <tc!*> ;

: <t@>  ( target-addr space -- tcell ) dup TO current-space   >space <t@*>  ;
: <t!>  ( tcell target-addr space -- ) dup TO current-space   >space <t!*>  ;

\ Returns the host-addr for the current THERE position.
: space>there ( space -- host-addr ) dup @ swap >space ;

\ API - Canonical spaces =====================================================
: tcode-c@ ( target-addr -- tchar ) code-there <tc@> ;
: tname-c@ ( target-addr -- tchar ) name-there <tc@> ;
: tdata-c@ ( target-addr -- tchar ) data-there <tc@> ;

: tcode@   ( target-addr -- tcell ) code-there <t@> ;
: tname@   ( target-addr -- tcell ) name-there <t@> ;
: tdata@   ( target-addr -- tcell ) data-there <t@> ;

: tcode-c! ( tchar target-addr -- ) code-there <tc!> ;
: tname-c! ( tchar target-addr -- ) name-there <tc!> ;
: tdata-c! ( tchar target-addr -- ) data-there <tc!> ;

: tcode!   ( tcell target-addr -- ) code-there <t!> ;
: tname!   ( tcell target-addr -- ) name-there <t!> ;
: tdata!   ( tcell target-addr -- ) data-there <t!> ;

\ API - Allot ======================================================================
: <t-allot> ( #tchars space -- )
  dup IS current-space
  tuck +!   \ Updated THERE   ( space )
  dup @ swap >space  ( host-addr )
  1- +max ;

: tname-allot ( #tchars -- ) name-there <t-allot> ;
: tcode-allot ( #tchars -- ) code-there <t-allot> ;
: tdata-allot ( #tchars -- ) data-there <t-allot> ;

: <t,> ( tcell space -- )
  tuck   dup @ swap <t!>
  1 tcells   swap <t-allot> ;

: tname,   ( tcell -- ) name-there <t,> ;
: tcode,   ( tcell -- ) code-there <t,> ;
: tdata,   ( tcell -- ) data-there <t,> ;

: <tc,> ( tchar space -- )
  tuck   dup @ swap <tc!>
  1 swap <t-allot> ;

: tname-c, ( tchar -- ) name-there <tc,> ;
: tcode-c, ( tchar -- ) code-there <tc,> ;
: tdata-c, ( tchar -- ) data-there <tc,> ;


\ API - Alignment ============================================================
\ Use t-allot to force the "max" logic to work.
: <t-align> ( there-ptr -- )
  dup @ dup taligned swap -   swap <t-allot> ;

: tname-align ( -- ) name-there <t-align> ;
: tcode-align ( -- ) code-there <t-align> ;
: tdata-align ( -- ) data-there <t-align> ;


\ Extras =====================================================================
: TVARIABLE ( "name" --    X: -- t-addr )
  data-there @   0 tdata,   CONSTANT ;


\ File output ================================================================
: extend-file ( offset file -- )
  ." Adjusting file to write at " over hex. cr
  >R s>d
  2dup R@ resize-file       ABORT" failed to resize file"
       R> hex .s cr reposition-file   ABORT" failed to reposition file" ;


: .space ( there-array -- )
  ." Space:" cr
  ." Current: " dup @ hex. cr
  ." Host:    " dup space>host-array @ hex. cr
  ." Max:     " dup space>max @ hex. cr
  ." Target:  " dup space>org @ hex. cr
  ." File:    "     space>offset @ hex. cr ;

: space>span ( there-array -- c-addr u )
  dup  space>host-array @
  swap space>max @
  over - 1+ ;

: dump-space ( there-array file -- )
  \ Bail if this space is the
  over data-there =   config data-space-blank? @ and IF
    ." Skipping the data space, it's uninitialized." cr
    2drop EXIT THEN

  ." dump-space: " over hex. dup hex. .s cr
  over .space
  >R
  dup space>offset @   R@ extend-file
  space>span
  ." Host span: " over hex. dup hex. cr
  \ cr cr 2dup native dump host
  ." File position: " R@ file-position ABORT" filepos failed" hex. hex. cr
  R> .s cr write-file ABORT" Failed to write file" ;

: .spaces ( -- )
  ." spaces order: "
  all-spaces @ BEGIN ?dup WHILE dup space>org @ hex.   space>next @ REPEAT cr ;

: sort-spaces ( -- )
  .spaces

  all-spaces @ space>next @ space>next dup @   0 rot ! ( code-space )
  all-spaces @   over space>next !
  all-spaces !

  .spaces ;


: dump ( c-addr u -- )
  cr cr ." Assembling to " 2dup type cr
  sort-spaces

  W/O BIN create-file ABORT" Failed to open output file" ( file )

  \ Write all the spaces which have been defined.
  all-spaces @ BEGIN ?dup WHILE ( file there-array )
    2dup swap dump-space
    space>next @
  REPEAT

  \ And close the file.
  dup flush-file ABORT" Failed to flush"
      close-file ABORT" Failed to close" ;
