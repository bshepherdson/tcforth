\ Common Forth high-level words
\ These are intended to be portable to any machine the metacompiler can target.
\ ANS Forth standard names and arguments where practical.
target definitions

\ LATEST gives the name token. Skip over the link pointer and check the length.
target : LATEST 'latest @ ;
  host acts: latest ;
target : IMMEDIATE latest cell+   dup @   $8000 or   swap ! ;
  host acts: latest tcell+ dup t@   f_immed or   swap t! ;

target : [ 0 state ! ; IMMEDIATE
  host acts: 0 state ! postpone host ; IMPERATIVE

target : ] 1 state ! ;
  host acts: postpone target meta] ;

target
: BL   32  ;
: 0<   0 < ;
: 0=   0 = ;
: 0>   0 swap < ;
: NOT  0= ;
: >    swap < ;
: <=   > not ;
: >=   < not ;
: U>   swap U< ;
: <>   = not ;

: /MOD ( a b -- r q ) 2dup mod   -rot / ;

\ Memory operations
: COUNT dup c@ >R char+ R> ;

target : ALLOT ( n -- ) dp +! ;
  host acts: dp +! ;

target : HERE dp @ ;
  host acts: dp @ ;

target : LITERAL ( C: x --    X: -- x ) [ host lit tliteral target ] compile, , ; IMMEDIATE
  host acts: ." (tliteral): " dup . tliteral ; IMPERATIVE

target : WITHIN ( x lo hi -- ? ) over - >R   - R> U< ;

\ Control structures
target : [0BRANCH]   [ host T0BRANCH tliteral target ] compile, ;
target : [BRANCH]    [ host TBRANCH  tliteral target ] compile, ;
target : ,DEST       , ;
target : !DEST ( dest slot -- ) here swap ! ;

target : IF   ( ? --     C: -- if-slot ) [0BRANCH]   here 0 ,dest ; IMMEDIATE
  host acts: T0BRANCH t,   here 0 ,dest ; IMPERATIVE
target : THEN ( ? --     C: if-slot -- ) here swap !dest ; IMMEDIATE
  host acts: here swap !dest ; IMPERATIVE
target : ELSE ( ? --     C: if-slot -- else-slot )
    [BRANCH] here 0 ,dest   swap here swap !dest ; IMMEDIATE
  host acts: TBRANCH  t,   here 0 ,dest   swap here swap !dest ; IMPERATIVE

target : BEGIN  ( --       C: -- top-loc ) here ; IMMEDIATE
  host acts: here ; IMPERATIVE
target : AGAIN  ( --       C: top-loc -- ) [BRANCH] ,dest ; IMMEDIATE
  host acts: TBRANCH tcompile, ,dest ; IMPERATIVE
target : WHILE  ( ? --     C: -- while-slot ) [0BRANCH] here 0 ,dest ; IMMEDIATE
  host acts: T0BRANCH tcompile,   here 0 ,dest ; IMPERATIVE
target : REPEAT ( --       C: top-loc while-slot )
    [BRANCH] swap ,dest   ( while-slot ) here swap !dest ; IMMEDIATE
  host acts: TBRANCH tcompile,   swap ,dest   here swap !dest ; IMPERATIVE


\ host cr cr hex
\ .s cr
\ (T') REPEAT
\ ." REPEAT mirror:   " dup                       hex. cr
\ ."   target xt:     " dup mirror>txt     @      hex. cr
\ ."   interp-xt:     " dup mirror>interp  @      hex. cr
\ ."   compile-xt:    " dup mirror>compile @      hex. cr
\ ."   h-does:        " dup mirror>h-does  @      hex. cr
\ ."   t-does:        " dup mirror>t-does  @      hex. cr
\ 
\ dup mirror>interp  @ xt-see cr
\ dup mirror>compile @ xt-see cr
\ drop
\ .s
\ decimal cr cr

target : POSTPONE ( "name" -- ) ' compile, ; IMMEDIATE
  host acts: T' tcompile, ; IMPERATIVE

target : CASE ( --   C: -- marker ) 0 ; IMMEDIATE
  host acts: 0 ; IMPERATIVE
target : OF   ( x1 x2 -- | x1    C: -- of-sys )
    postpone over postpone = postpone IF postpone drop ; IMMEDIATE
  host acts: TOVER tcompile, T= tcompile,
    target IF host TDROP tcompile, ; IMPERATIVE
target : ENDOF ( --   C: of-sys -- ) postpone ELSE ; IMMEDIATE
  host acts: target ELSE host ; IMPERATIVE
target : ENDCASE ( x --   C: jump-loc1 ... jump-locN -- )
    postpone drop BEGIN ?dup WHILE postpone THEN REPEAT ; IMMEDIATE
  host acts: TDROP tcompile,
    BEGIN ?dup WHILE target THEN host REPEAT ; IMPERATIVE

\ target : FOO 7 bl dup log <> log break ;
\ host T' FOO entry-point t!

host REQUIRE exceptions.ft
host REQUIRE input.ft

target : MOVE ( src dst u -- ) >R 2dup U< IF R> MOVE> ELSE R> MOVE< THEN ;


\ (CREATE) builds a blank header, no code field.
\ link | len | name... |
target : (CREATE) ( "name" -- ) here latest ,   'latest !
    parse-name dup c,
    here swap ( src dst u ) dup >R cmove R> ( len ) allot ;

target : CREATE ( "name" --     X: -- addr )
    (CREATE) [ host dovar tliteral target ] !cf ;
  host acts: (tcreate)   ,dovar ;


\ DOES> Design ===============================================================
\ There are 6 sequences of code that matter here:
\ Sequence 1a: Target : CONSTANT
\ Sequence 1b: Host ACTS: for same
\ Sequence 2a: Target exec of 3 CONSTANT pi
\ Sequence 2b: Host exec of 3 CONSTANT pi
\ Sequence 3a: Target exec of pi
\ Sequence 3b: Host exec of pi

\ Sequence 1:
\ TARGET DOES> is IMMEDIATE/IMPERATIVE.
\ a. On the target, it compiles (DOES>) | EXIT | dodoes-code into the dictionary
\ b. On the host, it compiles the same into the target, but then:
\    - Compiles LIT mirror-CONSTANT | (DOES>) | EXIT into the host action.
\    - Captures the target xt of the dodoes-code in mirror-CONSTANT slot 4.
\    - Uses VARIABLE doing? and HOST ; to capture the xt for the Host-side DOES>
\      action, saving it in slot 3 of mirror-CONSTANT.

\ Sequence 2:
\ a. TARGET (DOES>) uses its TORS (points to EXIT) to find the pointer to
\    dodoes-code and edit the code field to be JSR 'dodoes-code
\ b. HOST (DOES>) has mirror-CONSTANT pushed on the stack!
\    - Get target xt for DOES> code from it, and set target code field.
\    - Get host xt for DOES> code as well, and set the interp-xt for mirror-PI.

\ HOST (DOES>) runs when eg. CONSTANT is called interpretively (sequence 2) and
\ does two things:
\ 1. Mimic TARGET (DOES>)
\   Update the code field of the new Target word (xt in mirror word slot 0) to
\   be the Target DOES> address (slot 4).
\ 2. Change mirror interp-xt for the mirror word to be the Host DOES> xt.
\   That's stored in the mirror word's slot 3.

\ Sequence 3:
\ On the target - just works.
\ On the host, its compile and interp xts are set properly!


\ (DOES>) - implementing sequence 2 ==========================================
\ (DOES>) runs in eg. CONSTANT to properly compile a particular constant.
\ Inside target (DOES>), TORS points at the EXIT. Just after it is the
\ dodoes-code that should become the new codeword's jump location.
\ $7c20 is JSR lit on DCPU. DCPU-specific!
target : (DOES>) latest >cfa   $7c20 over !    cell+ R@ cell+ swap ! ;

\ On the host, mimic the target (DOES>). On the host side, the mirror body for
\ our defining word (eg. CONSTANT) is on the stack - it contains the target-xt
\ for the DOES> code, as well as the host-xt for the host's DOES> code!
host definitions
: (DOES>) ( mirror-CONSTANT -- )
  \ Step 1: Change the target code field to point to the does-code.
  dup mirror>t-does @   ?dup IF 'mirror @ mirror>txt @   !dodoes THEN  ( mirror-CONSTANT )
  \ Step 2: Change the newest 'mirror word's interp-xt to mirror-CONSTANT's
  \ h-does field.
  mirror>h-does @   'mirror @ mirror>interp ! ( ) ;

host T' (DOES>) '(DOES>) !
host T' EXIT    'EXIT !


\ DOES> - implementing sequence 1 ============================================
\ Target side: Compiles (DOES>) | EXIT | dodoes-code into the definition; saves
\ the dodoes-code address into the mirror word's t-does field.
\ Host side: Compiles the same into the target, but also compiles
\ LIT mirror-CONSTANT | (DOES>) | EXIT on the host.
\ Use the acting? and doing? flags in HOST ; to define the interp-xt (current
\ :noname) and target-does-xt (about to be started) actions.
target definitions
: DOES> ( -- )
    [ host T' (DOES>)   tliteral target ] tcompile,
    [ host T' EXIT      tliteral target ] tcompile,
    [ host jsr_docol t@ tliteral target ] t,               \ DCPU-specific
    ; IMMEDIATE
  host acts: does, 'mirror @ mirror>t-does ! ; IMPERATIVE
  \ This is just the Target side; it saves the target xt of target DOES> code
  \ Any defining word (eg. CONSTANT) with a Host action should have its own
  \ host acts: ... DOES> ... ; clause and that's when HOST DOES> below runs!

\ This is IMMEDIATE on the host and runs during compilation of the HOST ACTS:

host definitions
: DOES> ( -- )
  ." HOST DOES>" cr
  \ Compile LIT mirror-CONSTANT | (DOES>) | EXIT into the current Host word.
  'mirror @   postpone literal
  ['] (DOES>) compile,
  postpone ; \ This does the acting? logic: set the Host interp-xt for CONSTANT
  \ Next, start a new :noname and set doing? so the trailing HOST ; will put the
  \ xt into the h-does field of CONSTANT.
  ." doing? on" cr
  doing? on :noname
  \ By default our new definition will get its mirror body from >mirror, look
  \ up the target xt, and convert to a target body. We compile code into the new
  \ nameless definition here so that the user-facing HOST ACTS: ... DOES> ... ;
  \ expects ( target-body ) on the stack as normal.
  ['] >mirror compile, ['] @ compile,    ( mirror-body )
  ['] mirror>txt compile, ['] @ compile, ( target-xt )
  ['] t>body compile,                    ( target-body )
  \ Now we're ready to continue compiling the tail of the definition.
; IMMEDIATE

target definitions


\ Now we're ready to define the various defining words in the core!
target : VARIABLE ( "name" --     X: -- addr ) CREATE 0 , ;
  host acts: target create host 0 t,   DOES> ." host variable does>" ;
  \ Empty DOES> action, but that leaves the target-body on the stack.

host cr cr hex
.s cr
(T') !
." ! mirror:        " dup                       hex. cr
."   target xt:     " dup mirror>txt     @      hex. cr
."   interp-xt:     " dup mirror>interp  @      hex. cr
."   compile-xt:    " dup mirror>compile @      hex. cr
."   h-does:        " dup mirror>h-does  @      hex. cr
."   t-does:        " dup mirror>t-does  @      hex. cr

dup mirror>interp @ xt-see cr
dup mirror>h-does @ xt-see cr
drop
.s
decimal cr cr

target VARIABLE foo

host cr cr hex
.s cr
(T') foo
." foo mirror:      " dup                       hex. cr
."   target xt:     " dup mirror>txt     @      hex. cr
."   interp-xt:     " dup mirror>interp  @      hex. cr
."   compile-xt:    " dup mirror>compile @      hex. cr
."   h-does:        " dup mirror>h-does  @      hex. cr
."   t-does:        " dup mirror>t-does  @      hex. cr

dup mirror>interp @ xt-see cr
dup mirror>h-does @ xt-see cr
drop
.s
decimal cr cr

target 77 foo host hex .s cr target !
target foo @ host . cr

target : CONSTANT ( x "name" --    X: -- x ) CREATE , DOES> @ ;
  host acts: target create host t, DOES> t@ ;

host cr cr hex
.s cr
(T') CONSTANT
." CONSTANT mirror: " dup                       hex. cr
."   target xt:     " dup mirror>txt     @      hex. cr
."   interp-xt:     " dup mirror>interp  @      hex. cr
."   compile-xt:    " dup mirror>compile @      hex. cr
."   h-does:        " dup mirror>h-does  @      hex. cr
."   t-does:        " dup mirror>t-does  @      hex. cr

dup mirror>interp @ xt-see cr
dup mirror>h-does @ xt-see cr
drop
.s
decimal cr cr

target 7 CONSTANT bar

\ 7c20 = 0111 1100 0010 0000 = 011111 00001 00000 = JSR 1f = JSR lit


\ This needs to be the last line in the target compilation.
host latest var_latest t!

\ Input handling
\ 'SOURCE >IN and TIB are defined in the kernel, to avoid circular refs.
\ : SOURCE    'SOURCE 2@ ;
\ : SOURCE-ID 'source-id @ ;
\ : /STRING   ( c-addr u n -- c-addr' u' ) dup >R -   swap R> + swap ;
\ : BL        32 ;


