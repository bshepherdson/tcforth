\ Common Forth high-level words
\ These are intended to be portable to any machine the metacompiler can target.
\ ANS Forth standard names and arguments where practical.
target definitions

\ LATEST gives the name token. Skip over the link pointer and check the length.
target : LATEST 'latest @ ;
  host acts: drop latest ;
target : IMMEDIATE latest cell+   dup @   $8000 or   swap ! ;
  host acts: drop latest tcell+ dup t@   f_immed or   swap t! ;


target : [ 0 state ! ; IMMEDIATE
  host acts: drop   0 state ! ; IMPERATIVE

target : ] 1 state ! ;
  host acts: drop   postpone target ] ;

target
: BL   32  ;
: 0<   0 < ;
: 0=   0 = ;
: 0>   0 swap < ;
: NOT  0= ;
: >    swap < ;
: <=   > not ;
: >=   < not ;
: U>   swap U< ;
: <>   = not ;

: /MOD ( a b -- r q ) 2dup mod   -rot / ;

\ Memory operations
: COUNT dup c@ >R char+ R> ;

target : ALLOT ( n -- ) dp +! ;
  host acts: drop dp +! ;

target : HERE dp @ ;
  host acts: drop   dp @ ;

target : LITERAL ( C: x --    X: -- x ) [ host lit tliteral target ] compile, , ; IMMEDIATE
  host acts: drop ." (tliteral): " dup . tliteral ; IMPERATIVE

target : WITHIN ( x lo hi -- ? ) over - >R   - R> U< ;

\ Control structures
target : [0BRANCH]   [ host T0BRANCH tliteral target ] compile, ;
target : [BRANCH]    [ host TBRANCH  tliteral target ] compile, ;
target : ,DEST       , ;
target : !DEST ( dest slot -- ) here swap ! ;

target : IF   ( ? --     C: -- if-slot ) [0BRANCH]   here 0 ,dest ; IMMEDIATE
  host acts: drop T0BRANCH t,   here 0 ,dest ; IMPERATIVE
target : THEN ( ? --     C: if-slot -- ) here swap !dest ; IMMEDIATE
  host acts: drop here swap !dest ; IMPERATIVE
target : ELSE ( ? --     C: if-slot -- else-slot )
    [BRANCH] here 0 ,dest   swap here swap !dest ; IMMEDIATE
  host acts: drop TBRANCH  t,   here 0 ,dest   swap here swap !dest ; IMPERATIVE

target : BEGIN  ( --       C: -- top-loc ) here ; IMMEDIATE
  host acts: drop here ; IMPERATIVE
target : AGAIN  ( --       C: top-loc -- ) [BRANCH] ,dest ; IMMEDIATE
  host acts: drop TBRANCH tcompile, ,dest ; IMPERATIVE
target : WHILE  ( ? --     C: -- while-slot ) [0BRANCH] here 0 ,dest ; IMMEDIATE
  host acts: drop T0BRANCH tcompile,   here 0 ,dest ; IMPERATIVE
target : REPEAT ( --       C: top-loc while-slot )
    [BRANCH] swap ,dest   ( while-slot ) here swap !dest ; IMMEDIATE
  host acts: drop TBRANCH tcompile,   swap ,dest   here swap !dest ; IMPERATIVE

target : POSTPONE ( "name" -- ) ' compile, ; IMMEDIATE
  host acts: drop T' tcompile, ; IMPERATIVE

target : CASE ( --   C: -- marker ) 0 ; IMMEDIATE
  host acts: drop 0 ; IMPERATIVE
target : OF   ( x1 x2 -- | x1    C: -- of-sys )
    postpone over postpone = postpone IF postpone drop ; IMMEDIATE
  host acts: drop   TOVER tcompile, T= tcompile,
    target IF host TDROP tcompile, ; IMPERATIVE
target : ENDOF ( --   C: of-sys -- ) postpone ELSE ; IMMEDIATE
  host acts: drop target ELSE host ; IMPERATIVE
target : ENDCASE ( x --   C: jump-loc1 ... jump-locN -- )
    postpone drop BEGIN ?dup WHILE postpone THEN REPEAT ; IMMEDIATE
  host acts: drop TDROP tcompile,
    BEGIN ?dup WHILE target THEN host REPEAT ; IMPERATIVE

\ target : FOO 7 bl dup log <> log break ;
\ host T' FOO entry-point t!

host REQUIRE exceptions.ft
host REQUIRE input.ft

target : MOVE ( src dst u -- ) >R 2dup U< IF R> MOVE> ELSE R> MOVE< THEN ;


\ (CREATE) builds a blank header, no code field.
\ link | len | name... |
target : (CREATE) ( "name" -- ) here latest ,   'latest !
    parse-name dup c,
    here swap ( src dst u ) dup >R cmove R> ( len ) allot ;

target : CREATE ( "name" --     X: -- addr )
    (CREATE) [ host dovar tliteral target ] !cf ;
  \ 0 t@ is the "set pc, lit" at $0000 in the assembly.  DCPU-specific!
  host acts: drop (tcreate)   0 t@ t,   dovar t, ;

\ (DOES>) is the inner word for defining words. That is, it runs in CONSTANT to
\ properly compile a particular constant.
\ Inside target (DOES>), TORS points at the EXIT. Just after it is the
\ dodoes-code that should become the new codeword's jump location.
\ $7c20 is JSR lit on DCPU. DCPU-specific!
target : (DOES>) latest >cfa   $7c20 over !    cell+ R@ cell+ swap ! ;
\ No host side here; this is only executed on the target.

host T' (DOES>) '(DOES>) !
host T' EXIT    'EXIT !

\ Target side: Compiles (DOES>) | EXIT | dodoes-code into the definition.
\ Host side: Compiles the same into the target, but also does NATIVE DOES> to
\ define the host-side action for the defined word, eg. a particular CONSTANT.
\ Its incoming pointer is (I think) the mirror word's three cells. It should
\ look up the xt, advance it two target cells to the target parameter field,
\ then do whatever it needs to do, eg. t@ for a CONSTANT.
target : DOES> ( -- )
    [ host T' (DOES>)   tliteral target ] tcompile,
    [ host T' EXIT      tliteral target ] tcompile,
    [ host jsr_docol t@ tliteral target ] t,               \ DCPU-specific?
    ; IMMEDIATE
  host acts: drop does, native postpone DOES> host ; IMPERATIVE

target : VARIABLE ( "name" --     X: -- addr ) CREATE 0 , ;
  host acts: drop create 0 t,   native DOES> host @ 2 tcells + ;

host latest var_latest t!

\ START HERE - Munge the target vocabulary to not overlay the host and Forth
\ ones. It leads to too many obscure bugs if a word is missing.

\ Input handling
\ 'SOURCE >IN and TIB are defined in the kernel, to avoid circular refs.
\ : SOURCE    'SOURCE 2@ ;
\ : SOURCE-ID 'source-id @ ;
\ : /STRING   ( c-addr u n -- c-addr' u' ) dup >R -   swap R> + swap ;
\ : BL        32 ;


