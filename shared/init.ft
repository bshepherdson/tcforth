\ Last file for the topmost words like QUIT
target definitions

target : \   source >in ! drop ; IMMEDIATE
  host acts: native postpone \ host ; IMPERATIVE-BOTH

target : (   41 parse 2drop ; IMMEDIATE
  host acts: native 41 parse 2drop host ; IMPERATIVE-BOTH

\ Fundamental multi-line interpreter loop.
\ Separate from QUIT because it gets called by file readers as well.
target : (QUIT) ( -- )
  BEGIN refill WHILE
    [ host T' INTERPRET tliteral target ] catch
    CASE
    0   OF state @ 0=   source-id 0= and IF ."  ok" cr THEN ENDOF
    -1  OF aborted ENDOF
    ( exc# ) .ERROR cr aborted \ Print error message, clear stacks, and continue
    0 ENDCASE
  REPEAT ;

\ Empties the return stack, selects keyboard input, forces interpreter state,
\ and (QUIT)s to keep interpreting.
target : QUIT ( -- )
  [ host rp0 tliteral target ] rp!
  [ host T' [ tcompile, target ]
  10 base !
  src-keyboard 'source-id !
  (QUIT) ( TODO: BYE ) ;

\ NOTE: Nothing (initialized) should go into the data space after this point in
\ the code! If that's a nuisance, this could be indirected further.
host config data-space-blank? @ [IF]
  \ Span of the data space on the host.
  cr cr S" Compiling data initializers since data space starts blank!" type cr
  data-there space>span
  dup bytes/tchar /       ( host-addr u-bytes u-tchars )
  code-there @
  over tcode-allot        ( host-addr u-bytes u-tchars target-addr )
  tuck
  \ Compiles literals for ( src dst u ) in target terms.
  target : init-data ( -- )
    [ host tliteral data-there space>org @ tliteral tliteral target ]
    move ;

  host ( host-addr u-bytes target-addr )
  code-there >space ( host-src u-bytes host-dst )
  swap move
host [ELSE]
  \ With an initialized data space, there's nothing to do here.
  target : init-data ( -- ) ;
host [THEN]
target

\ Basic startup
: boot  ( -- ) init-data   init-hardware   10 base ! ;
: intro ( -- ) '.intro @ execute ;
\ "Cold" start, loading interactive mode.
: cold  ( -- ) boot intro QUIT ;

host   T' COLD   entry-point tcode!
