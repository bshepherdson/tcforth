\ The fundamental stack is:
\ INTERPRET interprets or compiles the line of Forth code in that buffer.
\ QUIT clears return stack (only) and does BEGIN refill WHILE interpret REPEAT
\ COLD clears data stack and calls QUIT

\ REFILL is clever and does the Right Thing for each source type:
\ Keyboard: ACCEPT
\ EVALUATE: just return 0
\ File:     read the next line; return 0 if no more
\ Block:    chain to the next block, I guess. (: -> refill drop ;)

\ The return stack is used as the input source stack as needed.
\ - EVALUATE pushes the old 'SOURCE and >IN to the return stack and puts the
\   string in their place, then calls INTERPRET. It restores when done.
\   - S" QUIT" EVALUATE works correctly - the old inputs are thrown away!
\ - REQUIRED and friends also work: they stack the current source, set up the
\   file as the new source, and QUIT

\ \ Input system
\ \ ============
\ \ 'SOURCE is a 2VARIABLE with ( c-addr len ) for the input buffer.
\ \ >IN is a VARIABLE holding the offset into that buffer.
\ \ Most of that system is written in hand-rolled Forth threads in a shared lib.
\ \ Here we just defined the variables.
\ label var_SOURCE    0 asm, 0 asm,
\ label var_SOURCE-ID 0 asm,
\ label var_TIB       256 there +!
\ label var_>IN       0 asm,
\ 
\ tcode 'SOURCE      var_SOURCE    # push set,  ;tcode
\ tcode 'SOURCE-ID   var_SOURCE-ID # push set,  ;tcode
\ tcode TIB          var_TIB       # push set,  ;tcode
\ tcode >IN          var_>IN       # push set,  ;tcode
\ 
\ 
\ : TSTR= ( c-addr u t-addr u -- ? )
\   rot over <> ( c-addr t-addr u len-diff? ) IF 2drop drop 0 EXIT THEN
\   0 DO ( c-addr t-addr )
\     over i + c@
\     over i + w@
\     <> IF 2drop UNLOOP EXIT THEN \ Different, so bail.
\   LOOP 2drop ;
\ 
\ : TFIND ( c-addr u -- nt|0 )
\   last-word @ BEGIN dup WHILE
\     >R 2dup R@ 1+   dup 1+ swap w@ mask_len and ( a u a u  ta len   R: nt )
\     TSTR= ( a u match?   R: nt ) IF 2drop R> EXIT THEN
\     R> w@ ( a u nt' )
\   REPEAT >R 2drop R> ;
\ 
\ : NT>CFA ( nt -- xt ) 1+ dup w@ mask_len and   + 1+ ;
\ 
\ 
\ \ Wrappers for the fundamental DCPU-family hardware instructions.
\ \ This allows the hardware interfaces to be written in high-level Forth.
\ tcode #DEVICES ( -- n )
\   ra hwn,
\   ra push set,
\ ;tcode
\ 
\ tcode DEVINFO ( dev-num -- version d-MAKER d-ID )
\   pop ra set,
\   ra hwq,     \ B:A is ID_hi:lo; C is version; Y:X is manufacturer.
\   rc push set,
\   rx push set,
\   ry push set,
\   ra push set,
\   rb push set,
\ ;tcode
\ 
\ \ Sends a hardware interrupt in DCPU style.
\ 
\ \ The stack before and after has the register values ordered
\ \ ( a b c x y z i j mask dev-num -- a b c x y z i j ) but only the ones in the
\ \ mask are included on either side.
\ \ The mask is JIZYXCBAjizyxcba, with the low bits being inputs and high ones
\ \ outputs.
\ label >DEVICE-saved-i 0 ,,
\ label >DEVICE-saved-z 0 ,,
\ label >DEVICE-dev     0 ,,
\ 
\ tcode >DEVICE
\   pop >DEVICE-dev       [#] set,
\   pop ex                    set, \ EX holds the mask
\ 
\   \ Save the meaningful registers.
\   rz  >DEVICE-saved-z [#] set,
\   ri  >DEVICE-stash-i [#] set,
\ 
\   \ Now get them off the stack.
\   $80 # ex ifb,    pop rj set,
\   $40 # ex ifb,    pop ri set,
\   $20 # ex ifb,    pop rz set,
\   $10 # ex ifb,    pop ry set,
\   $08 # ex ifb,    pop rx set,
\   $04 # ex ifb,    pop rc set,
\   $02 # ex ifb,    pop rb set,
\   $01 # ex ifb,    pop ra set,
\ 
\   \ Do the interrupt!
\   ex push set,
\   >DEVICE-dev [#] hwi,
\   pop  ex set,
\ 
\   $0100 # ex ifb,    ra push set,
\   $0200 # ex ifb,    rb push set,
\   $0400 # ex ifb,    rc push set,
\   $0800 # ex ifb,    rx push set,
\   $1000 # ex ifb,    ry push set,
\   $2000 # ex ifb,    rz push set,
\   $4000 # ex ifb,    ri push set,
\   $8000 # ex ifb,    rj push set,
\ 
\   \ Now restore our registers.
\   >DEVICE-saved-i [#]  ri  set,
\   >DEVICE-saved-z [#]  rz  set,
\ ;tcode
\ 
\ 
\ \ The above >DEVICE is pretty expensive, which is fine for occasional HWIs
\ \ like setting up the LEM1802 memory maps, but is really bad for reading the
\ \ keyboard. Thus (KEY) is separately coded to get the next key typed.
\ tcode (KEY) ( dev-num -- key )
\   1 # a set, \ Read next key
\   peek hwi,
\   0 # rc ife,
\     cf_(KEY) # pc set,
\   rc peek set, \ Overwrite the device number on top.
\ ;tcode
\ 
\ 
\ tcode DEBUG
\   0 # brk,
\ ;tcode
\ 
\ tcode (LOG)
\   pop log,
\ ;tcode
\ 
\ 
\ tcode (LOOP-END)
\   [z]     rx set,     \ X is the index
\   [z+1]   ry set,     \ Y is the limit
\   rx      rc set,
\   ry      rc sub,     \ C is i-l
\   pop     rj set,     \ J is the delta
\   \ We want delta + index - limit
\   rj      ra set,
\   rc      ra add,     \ A is delta + index - limit
\   rc      ra xor,     \ A is d+i-l ^ i-l
\   0 #     rb set,
\   $8000 # ra ifc,     \ True when top bit is clear.
\     -1 # rb set,
\   rb      ra set,     \ Keep the first flag in A.
\ 
\   \ Then calculate delta XOR index - limit
\   rj      rc xor,
\   0 #     rb set,
\   $8000 # rc ifc,
\     -1 # rb set,
\ 
\   rb      ra bor,     \ OR those flags
\   -1 #    ra xor,     \ and invert the result
\   ra    push set,
\   rx      rj add,     \ New index is delta + index
\   rj     [z] set,     \ Write it back to the stack.
\ ;tcode
\ 
\ 
\ tcode STATE
\   var_state # push set,
\ ;tcode
\ 
\ label var_latest 0 ,,
\ tcode LATEST
\   var_latest # push set,
\ ;tcode
\ 
\ tcode BASE
\   var_base # push set,
\ ;tcode
\ 
\ 
\ \ Interrupts ==================================
\ \ interrupt_handler is what actually gets IAS'd.
\ \ It's a machine code routine that sets up a Forth thread with the high-level
\ \ interrupt routine and its own tail routine.
\ \ The interrupt message is in A and the old A was pushed onto the stack. Since
\ \ we might be mid-routine elsewhere, we need to preserve that A!
\ \ The stack effect of the user handler is ( msg -- )
\ 
\ \ This is the tail-end routine that finishes the interrupt. It restores the old
\ \ registers off the stack and then does RFI.
\ label int-EXIT
\   \ Restoring JIYXCB - A is already saved, and we're using Z.
\   pop rj set,   pop ri set,   pop ry set,
\   pop rx set,   pop rc set,   pop rb set,
\   0 # rfi,
\ 
\ label interrupt-thread 0 ,, int-EXIT ,,
\ 
\ tcode (>INTERRUPT) ( xt -- )
\   pop   interrupt-thread [#]  set,  \ The first word of the thread.
\ ;tcode
\ 
\ label interrupt_handler
\   \ First a special case - if the interrupt word is 0, just bail since no one is
\   \ listening.
\   0 #   interrupt-thread [#] ife,
\     0 # rfi,
\ 
\   \ Gotta save ~all the registers, since Forth words might clobber nearly any
\   \ of them. Don't need to save Z or A (A is already saved; Z is handled safely)
\   rj push set,   ri push set,   ry push set,
\   rx push set,   rc push set,   rb push set,
\   \ Make the interrupt-thread the new I
\   interrupt-thread # ri set,
\   \ And NEXT into it!
\   next,
\ 
\ 
\ \ The high-level code will put the xt of COLD here for the startup code.
\ label 'COLD 0 ,,
\ 
\ \ Machine code entry point, jumped to by the first word at the top.
\ \ Mostly this sets up the code to call
\ label main
\   1 # iaq,                  \ Queueing on for safety.
\   interrupt_handler #  ias, \ Set up interrupts.
\   'COLD [#]         ri set,
\   0 # iaq,                  \ Queueing off, interrupts on.
\   next, \ Never returns to here.
\ 
\ 
